<!doctype html>
<html lang="ko" data-mode="default">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Handy! · 모션 인식 수화 학습 서비스</title>
  
  <!-- ===================== Safe stub & MediaPipe base ===================== -->
  <script>
    (function(){
      const q=[]; window.__pending_calls=q;
      window.__safe = new Proxy({}, { get(_t,prop){ if(prop==='then') return undefined; return (...args)=>q.push([prop,args]); }});
      window.__callSafe = function(name, ...args){ try{ const s=window.__safe; if(s && typeof s[name]==='function') return s[name](...args); q.push([name,args]); }catch(e){ console.warn('callSafe',e);} };
      // MediaPipe local base (adjust if needed)
      window.MP_BASE='libs/mediapipe';
      window.LOCATE_HOLISTIC=(f)=> `${MP_BASE}/holistic/${f}`;
    })();
  </script>
  
  <!-- ===================== MediaPipe (local bundles) ===================== -->
  <script src="libs/mediapipe/holistic/holistic.js"></script>
  <script src="libs/mediapipe/camera_utils/camera_utils.js"></script>
  <script src="libs/mediapipe/drawing_utils/drawing_utils.js"></script>

  <!-- ===================== KRDS-ish minimal design tokens ===================== -->
  <style>
    :root{
      /* Grays */
      --bg:#f6f7f9; --surface:#ffffff; --surface-2:#f3f4f6; --border:#e5e7eb; --ink:#0f172a; --ink-2:#334155;
      /* Primary */
      --primary-600:#0b4da2; --primary-700:#083e82; --primary-50:#e7eef7; --ring: var(--primary-600);
      /* System */
      --success-600:#16a34a; --warning-600:#d97706; --danger-600:#dc2626; --info-600:#2563eb;
      --radius:12px; --radius-lg:16px;
    }
    html[data-mode="vivid"]{ --bg:#0b1220; --surface:#0f172a; --surface-2:#111827; --border:#334155; --ink:#e5e7eb; --ink-2:#cbd5e1; --primary-600:#4f9cff; --primary-700:#1e7fe8; --primary-50:#0b1220; --ring:#93c5fd; }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0; font-family:Pretendard, "Pretendard GOV", system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans KR", Arial, sans-serif; background:var(--bg); color:var(--ink)}
    a{color:var(--primary-600); text-decoration:none} a:hover{text-decoration:underline}

    header{position:sticky; top:0; z-index:50; background:var(--surface); border-bottom:1px solid var(--border); backdrop-filter:saturate(180%) blur(6px)}
    main{max-width:1200px; margin:0 auto; padding:16px}
    .brand{font-weight:900; letter-spacing:-0.01em}

    .card{ background:var(--surface); border:1px solid var(--border); border-radius:var(--radius-lg); box-shadow:0 1px 2px rgba(0,0,0,.04); padding:16px }
    .muted{ color:var(--ink-2) }

    .btn{ --_bg:#111827; --_fg:#fff; --_bd:var(--border); border:1px solid var(--_bd); background:var(--_bg); color:var(--_fg); border-radius:var(--radius); padding:10px 14px; font-weight:700; cursor:pointer; line-height:1; display:inline-flex; align-items:center; gap:8px; letter-spacing:-0.01em }
    .btn:focus-visible{ outline:3px solid var(--ring); outline-offset:2px }
    .btn:hover{ filter:brightness(0.96) }
    .btn--primary{ --_bg:var(--primary-600); --_bd:var(--primary-700) }
    .btn--secondary{ --_bg:#fff; --_fg:#111827 }
    .btn--ghost{ --_bg:transparent; --_fg:var(--ink) }
    .btn[disabled]{ opacity:.5; cursor:not-allowed }

    .tabs{ display:flex; gap:6px }
    .tab-btn{ appearance:none; background:transparent; border:1px solid transparent; color:var(--ink-2); padding:10px 14px; border-radius:10px; font-weight:700; cursor:pointer }
    .tab-btn[aria-selected="true"]{ color:var(--ink); background:var(--surface-2); border-color:var(--border) }
    .tab-panel{ display:none }
    .tab-panel[aria-hidden="false"]{ display:block }

    .row{ display:flex; align-items:center; justify-content:space-between; gap:12px }

    .slot{ position:relative; aspect-ratio:16/9; background:#0001; border:1px solid var(--border); border-radius:12px; overflow:hidden }
    .slot > video, .slot > canvas{ position:absolute; inset:0; width:100%; height:100% }
.slot > video{ z-index:1 }
.slot > canvas{ z-index:2; pointer-events:none !important }
.slot > canvas{ pointer-events:none !important; }
.slot > canvas{ pointer-events:none !important }
    /*__overlay_zindex__*/
    .slot > video{ z-index:1 }
    .slot > canvas{ z-index:2 }
    .slot > video{ object-fit:contain; background:#000 }
    .slot > canvas{ pointer-events:none }

    ul.clean{ list-style:none; padding:0; margin:0 }

    #alert{ display:none; margin-top:12px; padding:10px 12px; border-radius:12px; border:1px solid var(--border) }
    #alert.show{ display:block }

    /* Mirror toggle (overlay only) */
    .mirror-toggle{ display:flex; align-items:center; gap:8px; margin:10px 8px 0; font-size:14px; color:#334155; user-select:none }
    .mirror-toggle .switch{ position:relative; width:44px; height:24px; background:#e5e7eb; border-radius:9999px; display:inline-block; vertical-align:middle; box-shadow:inset 0 0 0 1px #d1d5db; transition:background .2s ease; cursor:pointer }
    .mirror-toggle .switch::after{ content:""; position:absolute; top:2px; left:2px; width:20px; height:20px; border-radius:9999px; background:#fff; box-shadow:0 1px 2px rgba(0,0,0,.2); transition:transform .2s ease }
    .mirror-toggle input:checked + .switch{ background:#2563eb }
    .mirror-toggle input:checked + .switch::after{ transform:translateX(20px) }
    .mirror-toggle .label{ font-weight:600 }
  </style>
</head>
<body>
  <!-- ===================== Header ===================== -->
  <header>
    <div style="max-width:1200px;margin:0 auto;padding:12px 16px;display:flex;align-items:center;justify-content:space-between;gap:12px;">
      <div class="brand">Handy!</div>
      <nav role="tablist" aria-label="주 탭" class="tabs">
        <button class="tab-btn" role="tab" id="tabbtn-learn" aria-controls="panel-learn" aria-selected="true" data-tab="learn">학습</button>
        <button class="tab-btn" role="tab" id="tabbtn-lessons" aria-controls="panel-lessons" aria-selected="false" data-tab="lessons">레슨</button>
        <button class="tab-btn" role="tab" id="tabbtn-admin" aria-controls="panel-admin" aria-selected="false" data-tab="admin">관리자</button>
      </nav>
      <div style="display:flex;gap:8px;align-items:center;">
        <button id="btnMode" class="btn btn--secondary" title="선명한 화면 모드 토글">선명 모드</button>
      </div>
    </div>
  </header>

  <!-- ===================== Main ===================== -->
  <main>
    <div id="alert" class="card"></div>

    <!-- ===== Learn ===== -->
    <section id="panel-learn" class="tab-panel" role="tabpanel" aria-labelledby="tabbtn-learn" aria-hidden="false">
      <div style="display:grid;grid-template-columns:1.1fr 1.4fr;gap:16px;">
        <!-- Left: Dictionary -->
        <div class="card" id="dictCard">
          <div class="row">
            <h2 style="margin:0">수어 사전</h2>
            <small class="muted">관리자에서 <b>단어명_사전용</b>으로 업로드한 영상</small>
          </div>

          <div class="row" style="gap:8px;margin-top:8px;">
            <input id="dictSearch" class="btn btn--ghost" placeholder="단어 검색…" style="flex:1;border:1px solid var(--border);background:var(--surface);" />
            <button id="dictClear" class="btn">지우기</button>
          </div>

          <div class="slot" style="margin-top:10px;">
            <video id="dictVideo" controls playsinline preload="metadata"></video>
          </div>

          <ul id="dictList" class="clean" style="margin-top:10px;display:grid;gap:8px;max-height:220px;overflow:auto;"></ul>
        </div>

        <!-- Right: Live recognition -->
        <div style="display:grid;grid-template-rows:auto auto 1fr;gap:16px;">
          <div class="card" id="liveCard">
            <div class="row">
              <h2 style="margin:0">실시간 인식</h2>
              <div style="display:flex;gap:8px;flex-wrap:wrap">
                <button id="btnStartCam" class="btn btn--primary">카메라 켜기</button>
                <button id="btnCapture" class="btn">3초 캡처</button>
              </div>
            </div>
            <div class="slot" style="margin-top:10px;">
              <video id="liveVideo" playsinline muted></video>
              <canvas id="liveCanvas"></canvas>
            </div>
            <div class="mirror-toggle" id="mirrorToggleWrap">
              <input id="mirrorChk" type="checkbox" style="display:none" />
              <span class="switch" role="switch" aria-labelledby="mirrorLbl"></span>
              <span class="label" id="mirrorLbl">거울모드(오버레이만)</span>
            </div>
            <div style="display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-top:10px;">
              <div class="card" style="padding:12px;">
                <div class="muted" style="font-size:12px;">예측 레이블</div>
                <div id="predLabel" style="font-weight:900;font-size:24px;">—</div>
              </div>
              <div class="card" style="padding:12px;">
                <div class="muted" style="font-size:12px;">정확도(유사도)</div>
                <div><span id="predScore" style="font-weight:900;font-size:24px;">—</span><span class="muted"> / 100</span></div>
              </div>
            </div>
            <div style="margin-top:10px;">
              <div class="muted" style="font-size:12px;">Top-3</div>
              <ul id="topk" class="clean" style="margin-top:6px;display:grid;gap:4px;"></ul>
            </div>
          </div>

          <div class="card">
            <h3 style="margin:0">오늘의 미션</h3>
            <div class="card" style="margin-top:8px;">
              <div class="muted" style="font-size:12px;">목표 레이블</div>
              <div class="row" style="margin-top:6px;">
                <div id="targetLabel" style="font-weight:900;font-size:20px;">—</div>
                <button id="btnNextTarget" class="btn">다른 목표</button>
              </div>
            </div>
            <div style="margin-top:12px;">
              <div class="row muted"><span>XP 진행도</span><span id="xpText">0 / 100</span></div>
              <div style="height:8px;border-radius:999px;background:var(--surface-2);overflow:hidden;margin-top:6px;">
                <div id="xpBar" style="height:100%;width:0%;background:var(--primary-600);"></div>
              </div>
              <div id="badgeArea" class="muted" style="margin-top:8px;font-size:12px;"></div>
            </div>
          </div>

          <div class="card">
            <h3 style="margin:0">데이터셋 레이블</h3>
            <ul id="labelList" class="clean" style="margin-top:8px;display:grid;gap:6px;"></ul>
          </div>
        </div>
      </div>
    </section>

    <!-- ===== Lessons ===== -->
    <section id="panel-lessons" class="tab-panel" role="tabpanel" aria-labelledby="tabbtn-lessons" aria-hidden="true">
      <div class="card">
        <h2 style="margin:0">레슨 (기초 → 상황별 표현)</h2>
        <p class="muted" style="margin:6px 0 0 0">업로드된 레이블을 기반으로 이용 가능 여부를 표시합니다.</p>
        <div id="lessonUnits" style="margin-top:10px;display:grid;grid-template-columns:1fr 1fr;gap:12px;"></div>
      </div>
      <div class="card" style="margin-top:12px;display:flex;gap:8px;align-items:center;">
        <select id="quizUnit" class="btn btn--ghost" style="border:1px solid var(--border);background:var(--surface);"></select>
        <button id="btnStartQuiz" class="btn btn--primary">퀴즈 시작</button>
        <span id="quizPrompt" class="muted"></span>
      </div>
    </section>

    <!-- ===== Admin ===== -->
    <section id="panel-admin" class="tab-panel" role="tabpanel" aria-labelledby="tabbtn-admin" aria-hidden="true">
      <div style="display:grid;grid-template-columns:1.7fr 1fr;gap:16px;">
        <div class="card">
          <h2 style="margin:0">영상 업로드 & 랜드마크 추출</h2>
          <p class="muted" style="margin:6px 0 0 0">여러 파일 선택 시 일괄 처리. <b>파일명 = 레이블</b> (예: <code>감사합니다_사전용.mp4</code>)</p>
          <div style="margin-top:10px;"><input id="adminVideo" type="file" accept="video/*" multiple /></div>
          <div style="margin-top:8px;display:flex;gap:8px;flex-wrap:wrap">
            <button id="btnProcessVideo" class="btn btn--primary">추출 & 저장</button>
            <button id="btnExport" class="btn">데이터셋 내보내기</button>
            <label class="btn btn--secondary" style="cursor:pointer;">
              데이터셋 가져오기 <input id="importJson" type="file" accept="application/json" hidden />
            </label>
          </div>
          <div style="margin-top:6px;display:flex;gap:12px;align-items:center;" class="muted">
            <label><input id="chkVerbose" type="checkbox" checked /> 상세 로그</label>
            <label><input id="chkOverlay" type="checkbox" checked /> 분석 오버레이</label>
            <button id="btnClearLog" class="btn btn--ghost" style="border:1px solid var(--border);">로그 지우기</button>
          </div>
          <div style="margin-top:10px;">
            <div class="slot">
              <video id="adminPreview" playsinline muted preload="auto" autoplay></video>
              <canvas id="adminCanvas"></canvas>
            </div>
            <pre id="adminLog" class="card" style="margin-top:8px;white-space:pre-wrap;height:180px;overflow:auto;font:12px/1.35 ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;"></pre>
          </div>
        </div>
        <div class="card">
          <h3 style="margin:0">데이터셋</h3>
          <p class="muted" style="margin:6px 0 0 0">브라우저(LocalStorage)에 저장됩니다.</p>
          <div style="margin-top:8px;display:flex;gap:8px;flex-wrap:wrap">
            <button id="btnRefreshDS" class="btn btn--secondary">새로고침</button>
            <button id="btnClearDS" class="btn" style="background:var(--danger-600);border-color:#b91c1c;">전체 삭제</button>
          </div>
          <ul id="datasetList" class="clean" style="margin-top:10px;display:grid;gap:8px;"></ul>
        </div>
      </div>
    </section>
  </main>

  <!-- ===================== Scripts ===================== -->
  <script>
  // ===== Utilities =====
  const $=(s)=>document.querySelector(s), $$=(s)=>Array.from(document.querySelectorAll(s));
  const alertBox = $('#alert');
  function showAlert(msg, kind='info'){
    const map={info:'var(--info-600)', ok:'var(--success-600)', warn:'var(--warning-600)', err:'var(--danger-600)'};
    alertBox.textContent=msg; alertBox.classList.add('show');
    alertBox.style.boxShadow=`inset 0 0 0 2px ${map[kind]||map.info}33`;
    setTimeout(()=>alertBox.classList.remove('show'), 3000);
  }

  // ===== Storage keys =====
  const DS_KEY='ksl_dataset_v8', XP_KEY='ksl_xp_v8', TARGET_KEY='ksl_target_v8';
  const DICT_DB='ksl_dict_v1', DICT_STORE='videos';

  // ===== Dataset storage (LocalStorage) =====
  const loadDS=()=>{ try{return JSON.parse(localStorage.getItem(DS_KEY)||'[]');}catch{return []} };
  const saveDS=(ds)=>{ localStorage.setItem(DS_KEY, JSON.stringify(ds)); refreshDatasetList(); buildLessonUnits(); refreshLabelList(); };
  const getXP=()=>parseInt(localStorage.getItem(XP_KEY)||'0',10), setXP=(v)=>{ localStorage.setItem(XP_KEY,String(v)); renderXP(); };
  const getTarget=()=>localStorage.getItem(TARGET_KEY)||'—', setTarget=(l)=>{ localStorage.setItem(TARGET_KEY,l); const t=$('#targetLabel'); if(t) t.textContent=l; };

  function renderXP(){ const xp=getXP(); $('#xpText').textContent=`${xp} / 100`; $('#xpBar').style.width=Math.min(100,xp)+'%'; const b=$('#badgeArea'); b.innerHTML=''; if(xp>=20)b.innerHTML+='<div>🥉 Newbie</div>'; if(xp>=50)b.innerHTML+='<div>🥈 Apprentice</div>'; if(xp>=100)b.innerHTML+='<div>🥇 Master</div>'; }
  function maybeAwardXP(pred,score){ const t=getTarget(); if(!t||t==='—')return; if(pred===t && score>=70){ const add=10+Math.round((score-70)/3); setXP(Math.min(100,getXP()+add)); showAlert(`목표 성공! +${add} XP`,'ok'); } }

  // ===== Lessons =====
  const LESSON_PLAN=[
    {id:'u0', title:'기초 인사', items:['안녕하세요','감사합니다','미안합니다','잘가요']},
    {id:'u1', title:'자기소개', items:['이름','나라','나이','직업']},
    {id:'u2', title:'숫자·시간', items:['하나','둘','셋','몇 시','오늘']},
    {id:'u3', title:'일상 필수', items:['물','밥','화장실','도와주세요']},
    {id:'u4', title:'쇼핑', items:['얼마예요','싸게','카드','영수증']},
    {id:'u5', title:'길찾기', items:['어디','오른쪽','왼쪽','지하철']},
    {id:'u6', title:'긴급 상황', items:['위험','병원','경찰']}
  ];

  function buildLessonUnits(){ const ds=loadDS(); const labels=new Set(ds.map(x=>x.label)); const wrap=$('#lessonUnits'); if(!wrap) return; wrap.innerHTML=''; LESSON_PLAN.forEach(u=>{ const card=document.createElement('div'); card.className='card'; const avail=u.items.filter(t=>labels.has(t)); const html=`<div class='row'><div class='font-semibold'>${u.title}</div><button class='btn' data-action='quiz-from-unit' data-unit='${u.id}'>퀵 퀴즈</button></div><div class='muted' style='margin-top:6px;font-size:14px;'><div class='font-medium'>학습 가능 (${avail.length}/${u.items.length})</div><ul class='clean' style='margin-top:6px;display:grid;gap:4px;'>${u.items.map(t=>{ const has=labels.has(t); const status=has? '<span style="color:var(--success-600)">사용 가능</span>' : '<span class="muted">샘플 없음</span>'; const btn=has? `<button class='btn btn--ghost' style='border:1px solid var(--border);padding:4px 8px;font-size:12px' data-action='set-target' data-label='${t}'>목표로</button>`:''; return `<li class='row'>• ${t}<span>${status}</span>${btn}</li>`; }).join('')}</ul></div>`; card.innerHTML=html; wrap.appendChild(card); }); const sel=$('#quizUnit'); if(sel){ sel.innerHTML=''; LESSON_PLAN.forEach(u=>{ const op=document.createElement('option'); op.value=u.id; op.textContent=u.title; sel.appendChild(op); }); } }
  function runQuiz(unitId){ const unit=LESSON_PLAN.find(u=>u.id===unitId)||LESSON_PLAN[0]; const labels=new Set(loadDS().map(x=>x.label)); const candidates=(unit?.items||[]).filter(l=>labels.has(l)); const el=$('#quizPrompt'); if(!candidates.length){ el.textContent='이 유닛엔 사용 가능한 레이블이 없습니다.'; return; } const pick=candidates[Math.floor(Math.random()*candidates.length)]; setTarget(pick); el.textContent=`목표: ${pick} — 3초 캡처를 눌러 맞춰보세요!`; }

  // ===== Dataset UI =====
  function refreshDatasetList(){ const ds=loadDS(); const ul=$('#datasetList'); if(!ul) return; if(!ds.length){ ul.innerHTML='<li class="muted">데이터셋 없음</li>'; return; } ul.innerHTML=''; ds.forEach((it,i)=>{ const li=document.createElement('li'); li.className='card'; li.innerHTML=`<div class='row'><div><div class='font-semibold'>[#${i+1}] ${it.label}</div><div class='muted' style='font-size:12px'>frames:${it.frames}, dim:${it.dim}, added:${new Date(it.added).toLocaleString()}</div></div><button class='btn btn--ghost' style='border:1px solid var(--border);' data-del='${it.id}'>삭제</button></div>`; ul.appendChild(li); }); ul.querySelectorAll('[data-del]').forEach(b=>b.addEventListener('click',()=>{ const id=b.dataset.del; const nd=loadDS().filter(x=>x.id!==id); saveDS(nd); showAlert('삭제 완료','ok'); })); }
  function refreshLabelList(){ const ds=loadDS(); const labels=[...new Set(ds.map(x=>x.label))].sort(); const ul=$('#labelList'); if(!ul) return; ul.innerHTML = labels.length ? labels.map(l=>`<li><button class='btn btn--ghost' style='border:1px solid var(--border);padding:4px 8px;font-size:12px' data-action='set-target' data-label='${l}'>${l}</button></li>`).join('') : '<li class="muted">데이터셋이 비어 있습니다.</li>'; if(labels.length && getTarget()==='—') setTarget(labels[0]); else $('#targetLabel').textContent=getTarget(); }

  // ===== Feature extraction =====
  const POSE_IDXS=[11,12,13,14,15,16];
  const normPose=(lm)=>{ const L=lm?.[11],R=lm?.[12]; if(!L||!R) return new Array(12).fill(0); const o={x:(L.x+R.x)/2,y:(L.y+R.y)/2}; const s=Math.max(1e-6,Math.hypot(L.x-R.x,L.y-R.y)); const out=[]; for(const i of POSE_IDXS){ const p=lm?.[i]; out.push(p? (p.x-o.x)/s:0, p? (p.y-o.y)/s:0);} return out; };
  const normHand=(h)=>{ if(!h||!h.length) return new Array(42).fill(0); const w=h[0]; const m=h[5]||w; const s=Math.max(1e-6,Math.hypot(m.x-w.x,m.y-w.y)); const out=[]; for(const p of h){ out.push((p.x-w.x)/s,(p.y-w.y)/s);} while(out.length<42) out.push(0); return out.slice(0,42); };
  const feat=(r)=> normPose(r.poseLandmarks).concat(normHand(r.leftHandLandmarks), normHand(r.rightHandLandmarks));
  const downsample=(seq,t=30)=>{ if(seq.length<=t) return seq.slice(); const out=[]; const step=seq.length/t; for(let i=0;i<t;i++) out.push(seq[Math.floor(i*step)]); return out; };
  const dist=(a,b)=>{ let s=0; for(let i=0;i<a.length;i++){ const d=a[i]-b[i]; s+=d*d;} return Math.sqrt(s); };
  const dtw=(A,B)=>{ const n=A.length,m=B.length,INF=1e15; const dp=Array.from({length:n+1},()=>new Float64Array(m+1).fill(INF)); dp[0][0]=0; for(let i=1;i<=n;i++){ for(let j=1;j<=m;j++){ const c=dist(A[i-1],B[j-1]); const b=Math.min(dp[i-1][j],dp[i][j-1],dp[i-1][j-1]); dp[i][j]=c+b; }} return dp[n][m]/(n+m); };
// === Robust helpers ===
// sumAbsRange: sum of absolute values in [s, e)
function sumAbsRange(v, s, e){ let t=0; for(let i=s;i<e;i++) t += Math.abs(v[i]||0); return t; }
// hands present?
function isHandsFrame(vec){
  const L = sumAbsRange(vec, 12, 54);
  const R = sumAbsRange(vec, 54, 96);
  return (L + R) > 1e-3;
}
// crop to active window where hands are present (with small padding)
function cropActive(seq){
  try{
    const idx=[]; for(let i=0;i<seq.length;i++){ if(isHandsFrame(seq[i])) idx.push(i); }
    if(!idx.length) return seq.slice();
    let a=idx[0], b=idx[idx.length-1];
    if(b - a + 1 < 10){
      const need = 10 - (b - a + 1);
      a = Math.max(0, a - Math.ceil(need/2));
      b = Math.min(seq.length-1, b + Math.floor(need/2));
    }
    return seq.slice(a, b+1);
  }catch(e){ return seq.slice(); }
}
// swap left/right hands in a feature vector [pose(12), L(42), R(42)]
function swapHands(vec){
  const pose = vec.slice(0,12);
  const L = vec.slice(12,54);
  const R = vec.slice(54,96);
  return pose.concat(R, L);
}function classify(seq){
  const ds = loadDS();
  if (!ds.length) return { label: '(데이터셋 없음)', score: 0, topK: [] };

  // 입력 시퀀스(보통 30프레임)에서 활동 구간만 추출
  const q0 = Array.isArray(seq) ? seq.slice() : [];
  const q = cropActive(q0);

  // 레이블별 최소 DTW 거리 수집 (미러 불변 + 손=0 비율 필터)
  const isNullHands = (vec) => {
    const L = sumAbsRange(vec, 12, 54);
    const R = sumAbsRange(vec, 54, 96);
    return (L + R) < 1e-3;
  };

  const per = new Map();
  for (const it of ds) {
    let cand = it.data || [];
    if (!cand.length) continue;

    // cand는 이미 30프레임 다운샘플 되어 있음 → 활동구간만 크롭
    const c = cropActive(cand);

    // 손=0 프레임 비율이 높으면 '제외' 대신 재측정(fallback) 적용
    const nullRatio = c.length ? c.filter(isNullHands).length / c.length : 1;
    let cUse = c;
    if (nullRatio > 0.6) {
      const c2 = c.filter(f => !isNullHands(f));
      // 너무 짧지 않으면(최소 10프레임 또는 원래의 40%) c2로 대체, 아니면 포즈 기반으로 원본 유지
      if (c2.length >= Math.min(10, Math.floor(c.length * 0.4))) cUse = c2;
    }
// 미러 불변 거리 (원본 vs 손-스왑 중 더 작은 값)
    const d = Math.min(
      dtw(q, cUse),
      dtw(q, cUse.map(swapHands))
    );

    const prev = per.get(it.label);
    if (!prev || d < prev.dist) per.set(it.label, { dist: d });
  }

  const pairs = Array.from(per.entries()).map(([label, { dist }]) => ({ label, dist }));
  if (!pairs.length) return { label: '(유효 샘플 없음)', score: 0, topK: [] };

  // --- v5 스타일 점수화 — per-query alpha + 확률 정규화 ---
  function _median(arr){ if(!arr.length) return 1.0; const s=[...arr].sort((a,b)=>a-b); return s[Math.floor(s.length/2)]||1.0; }
  const _dists = pairs.map(p=>p.dist).filter(d=>Number.isFinite(d)&&d>=0);
  let _scale = _median(_dists);
  if(!isFinite(_scale) || _scale <= 1e-6) _scale = 1.0;
  let alpha = 1/Math.max(1e-3, _scale);        // 안전 하한
  alpha = Math.min(Math.max(alpha, 0.02), 0.8); // 0.02~0.8로 클램프(붕괴 방지)

  const exps = pairs.map(p => Math.exp(-alpha * p.dist));
  const Z = exps.reduce((a,b)=>a+b, 0) || 1;
  const scored = pairs
    .map((p,i) => ({ label: p.label, score: exps[i] / Z }))
    .sort((a,b)=> b.score - a.score);

  const best = scored[0] || { label:'—', score:0 };
  const second = scored[1] || { label:'—', score:0 };
  const margin = best.score - second.score;

  // 불확실 거부(표시는 하지 않고 내부적으로만 플래그)
const TH = 0.55, MARGIN = 0.10;
const __uncertain = !(best.score >= TH && margin >= MARGIN);
// 요청사항: 미확실 대신 1등 라벨을 그대로 사용
return { label: best.label, score: best.score, topK: scored.slice(0,3), uncertain: __uncertain };}

function renderPred(r){
  const label = r?.label || '—';
  const pct   = Math.round((r?.score || 0) * 100);

  // 라벨
  const labEl = $('#predLabel');
  if (labEl) labEl.textContent = label;

  // 점수 게이지/텍스트 동시 업데이트 (무엇이든 대응)
  const sEl = $('#predScore');
  if (sEl) {
    // 1) 게이지/슬라이더/미터인 경우
    if ('value' in sEl) sEl.value = pct;        // <progress>, <input type="range">, <meter> 등
    // 2) 접근성/스타일 훅
    sEl.setAttribute('aria-valuenow', String(pct));
    sEl.dataset.value = String(pct);
    // CSS 변수로 너비를 그리는 경우를 대비
    sEl.style?.setProperty?.('--score', pct);

    // 3) 텍스트 노드인 경우(스팬/디브)도 동작
    //    (게이지가 아닌 단순 숫자 요소라면 이 한 줄만으로도 표시됨)
    sEl.textContent = String(pct);
  }

  // Top-K 리스트
  const ul = $('#topk');
  if (ul) {
    ul.innerHTML = '';
    (r.topK || []).forEach((x, i) => {
      const li = document.createElement('li');
      li.textContent = `${i+1}. ${x.label} — ${(x.score*100).toFixed(1)}`;
      ul.appendChild(li);
    });
  }

  // 디버그: 실제 확률이 얼마인지 콘솔로 확인 (원하면 주석 처리)
  // console.log('pred', { label, pct, r });
}


  // ===== Canvas overlay drawing =====
  function syncCanvasToContainer(c){ const dpr=Math.max(1,window.devicePixelRatio||1); const r=c.getBoundingClientRect(); const w=Math.max(1,Math.floor(r.width*dpr)), h=Math.max(1,Math.floor(r.height*dpr)); if(c.width!==w||c.height!==h){ c.width=w; c.height=h; } }
  function drawOverlay(ctx,r,videoEl,canvasEl){ if(!ctx){return;} ctx.clearRect(0,0,ctx.canvas.width,ctx.canvas.height); if(!r){return;} const vw=Math.max(1,(videoEl?.videoWidth||1)), vh=Math.max(1,(videoEl?.videoHeight||1)); const cw=canvasEl?.width||ctx.canvas.width, ch=canvasEl?.height||ctx.canvas.height; const s=Math.min(cw/vw,ch/vh); const dw=vw*s, dh=vh*s; const ox=(cw-dw)/2, oy=(ch-dh)/2; const map=(p)=>({x:ox+(p.x||0)*dw, y:oy+(p.y||0)*dh}); const HAND=[[0,1],[1,2],[2,3],[3,4],[0,5],[5,6],[6,7],[7,8],[0,9],[9,10],[10,11],[11,12],[0,13],[13,14],[14,15],[15,16],[0,17],[17,18],[18,19],[19,20]]; const ARM=[[11,12],[11,13],[13,15],[12,14],[14,16]]; const lines=(lm,edges,color='#22c55e',lw=3)=>{ if(!lm||!lm.length)return; ctx.save(); ctx.lineJoin='round'; ctx.lineCap='round'; ctx.beginPath(); ctx.strokeStyle='rgba(255,255,255,0.9)'; ctx.lineWidth=lw+2; edges.forEach(([a,b])=>{ const pa=lm[a],pb=lm[b]; if(!pa||!pb) return; const A=map(pa),B=map(pb); ctx.moveTo(A.x,A.y); ctx.lineTo(B.x,B.y); }); ctx.stroke(); ctx.beginPath(); ctx.strokeStyle=color; ctx.lineWidth=lw; edges.forEach(([a,b])=>{ const pa=lm[a],pb=lm[b]; if(!pa||!pb) return; const A=map(pa),B=map(pb); ctx.moveTo(A.x,A.y); ctx.lineTo(B.x,B.y); }); ctx.stroke(); ctx.restore(); }; const dots=(lm,color='#16a34a',rad=3)=>{ if(!lm||!lm.length)return; ctx.save(); for(const p of lm){ const P=map(p); ctx.beginPath(); ctx.fillStyle='rgba(255,255,255,0.9)'; ctx.arc(P.x,P.y,rad+1,0,Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.fillStyle=color; ctx.arc(P.x,P.y,rad,0,Math.PI*2); ctx.fill(); } ctx.restore(); }; try{ if(r.poseLandmarks){ lines(r.poseLandmarks, (window.drawingUtils?.POSE_CONNECTIONS)||ARM, '#22c55e', 3); dots(r.poseLandmarks,'#16a34a',3); } if(r.leftHandLandmarks){ lines(r.leftHandLandmarks, (window.drawingUtils?.HAND_CONNECTIONS)||HAND, '#0ea5e9', 3); dots(r.leftHandLandmarks,'#0284c7',3); } if(r.rightHandLandmarks){ lines(r.rightHandLandmarks, (window.drawingUtils?.HAND_CONNECTIONS)||HAND, '#ef4444', 3); dots(r.rightHandLandmarks,'#dc2626',3); } }catch{}
  }

  // ===== Live capture =====
  const liveVideo=$('#liveVideo'), liveCanvas=$('#liveCanvas'), liveCtx=liveCanvas.getContext('2d');
  let holLive=null, cameraLive=null, capturing=false, captureBuf=[];
  function holisticClass(){ if(typeof window.Holistic==='function') return window.Holistic; if(window.Holistic&&typeof window.Holistic.Holistic==='function') return window.Holistic.Holistic; return null; }
  async function ensureHolLive(){ const Hol=holisticClass(); if(!Hol) throw new Error('로컬 MediaPipe(holistic.js) 경로 확인: '+LOCATE_HOLISTIC('holistic.js')); if(holLive) return holLive; holLive=new Hol({ locateFile:LOCATE_HOLISTIC }); holLive.setOptions({ modelComplexity:2, minDetectionConfidence:0.6, minTrackingConfidence:0.6, selfieMode:true, smoothLandmarks:true }); holLive.onResults((r)=>{ if(!liveVideo.videoWidth) return; syncCanvasToContainer(liveCanvas); // mirror overlay data-mode

// --- 실시간: selfieMode=true 기준으로 들어온 '왼/오' 라벨을 관리자 데이터와 맞춤 ---
let L = r.leftHandLandmarks || null;
let R = r.rightHandLandmarks || null;
// 실시간(셀피) 입력은 라벨이 거울 기준일 수 있으므로 한 번만 swap
{ const tmp = L; L = R; R = tmp; }

// 오버레이/특징 좌표계 일치: 토글 OFF일 때만 데이터 좌우 뒤집기
const needFlipData = (liveCanvas?.dataset?.mirror === 'data');
const mapX = needFlipData
  ? (arr)=> Array.isArray(arr) ? arr.map(p => ({...p, x: 1 - (p.x || 0)})) : arr
  : (arr)=> arr;

// 교정된 r로 치환 (pose/face도 동일 규칙 적용)
r = {
  ...r,
  leftHandLandmarks:  mapX(L),
  rightHandLandmarks: mapX(R),
  poseLandmarks:      mapX(r.poseLandmarks),
  faceLandmarks:      mapX(r.faceLandmarks),
};

    const cv=liveCanvas; if(cv?.dataset?.mirror==='data'){ const m=(arr)=>Array.isArray(arr)?arr.map(p=>({...p, x:1-(p.x||0)})):arr; r={...r, poseLandmarks:m(r.poseLandmarks), leftHandLandmarks:m(r.leftHandLandmarks), rightHandLandmarks:m(r.rightHandLandmarks), faceLandmarks:m(r.faceLandmarks)}; }
    drawOverlay(liveCtx,r,liveVideo,liveCanvas); if(capturing){ captureBuf.push(feat(r)); }
  }); return holLive; }
  async function startCamera(){ const hol=await ensureHolLive(); cameraLive=new Camera(liveVideo,{ width:960, height:540, onFrame: async()=>{ await hol.send({ image: liveVideo }); } }); await cameraLive.start(); showAlert('카메라 시작','ok'); }

  // ===== Admin: logging helper =====
  const adminVideo=$('#adminVideo'), adminPreview=$('#adminPreview'), adminCanvas=$('#adminCanvas'), adminCtx=adminCanvas.getContext('2d');
  const adminLog=$('#adminLog'), chkVerbose=$('#chkVerbose'), chkOverlay=$('#chkOverlay');
  const log=(t)=>{ const line=`[${new Date().toLocaleTimeString()}] ${t}`; adminLog.textContent += (adminLog.textContent?"\n":"")+line; adminLog.scrollTop=adminLog.scrollHeight; console.log(line); };
  const deriveLabel=(name)=> name.replace(/\.[^.]+$/,'').trim();
  async function ensureHolAdmin(){ const Hol=holisticClass(); if(!Hol) throw new Error('로컬 MediaPipe(holistic.js)를 찾을 수 없습니다. 경로 확인: '+LOCATE_HOLISTIC('holistic.js')); const hol=new Hol({ locateFile:LOCATE_HOLISTIC }); hol.setOptions({ modelComplexity:1, minDetectionConfidence:0.5, minTrackingConfidence:0.6, selfieMode:false, smoothLandmarks:true, refineFaceLandmarks:false }); return hol; }
  async function ensureVideoAutoPlay(v){ try{ v.autoplay=true; v.muted=true; v.playsInline=true; v.preload='auto'; await v.play(); }catch(e){ const once=()=>{ v.play().catch(()=>{}); document.removeEventListener('click',once); }; document.addEventListener('click',once,{once:true}); showAlert('브라우저가 자동재생을 제한했습니다. 화면을 한 번 클릭하면 재생됩니다.','warn'); } }

  // ===== IndexedDB (dictionary videos) =====
  function idbOpen(){ return new Promise((resolve,reject)=>{ const r=indexedDB.open(DICT_DB,1); r.onupgradeneeded=(e)=>{ const db=e.target.result; if(!db.objectStoreNames.contains(DICT_STORE)){ db.createObjectStore(DICT_STORE,{keyPath:'key'}); } }; r.onsuccess=()=>resolve(r.result); r.onerror=()=>reject(r.error); }); }
  async function dictPut(label, file){ const db=await idbOpen(); return new Promise((resolve,reject)=>{ const tx=db.transaction(DICT_STORE,'readwrite'); tx.oncomplete=()=>resolve(true); tx.onerror=()=>reject(tx.error); const store=tx.objectStore(DICT_STORE); store.put({key:label, type:file.type||'video/mp4', blob:file}); }); }
  async function dictGet(label){ const db=await idbOpen(); return new Promise((resolve,reject)=>{ const tx=db.transaction(DICT_STORE,'readonly'); const store=tx.objectStore(DICT_STORE); const req=store.get(label); req.onsuccess=()=>resolve(req.result||null); req.onerror=()=>reject(req.error); }); }
  async function dictKeys(){ const db=await idbOpen(); return new Promise((resolve,reject)=>{ const tx=db.transaction(DICT_STORE,'readonly'); const store=tx.objectStore(DICT_STORE); if(store.getAllKeys){ const req=store.getAllKeys(); req.onsuccess=()=>resolve(req.result||[]); req.onerror=()=>reject(req.error); } else { const out=[]; const cur=store.openCursor(); cur.onsuccess=(e)=>{ const c=e.target.result; if(c){ out.push(c.key); c.continue(); } else resolve(out); }; cur.onerror=()=>reject(cur.error); } }); }

  // ===== Dictionary UI =====
  async function renderDictList(filter=''){ const ul=$('#dictList'); if(!ul) return; const keys=(await dictKeys()).map(String).sort(); const q=(filter||'').toLowerCase(); const list=keys.filter(k=>k.toLowerCase().includes(q)); ul.innerHTML = list.length ? list.map(k=>`<li class="row"><span>${k}</span><button class="btn btn--ghost" style="border:1px solid var(--border);padding:4px 8px;font-size:12px" data-action="play-dict" data-label="${k}">재생</button></li>`).join('') : '<li class="muted">사전 항목이 없습니다.</li>'; }
  async function playDict(label){ const item=await dictGet(label); if(!item){ showAlert('사전 영상이 없습니다. 관리자에서 업로드하세요.','warn'); return; } const url=URL.createObjectURL(item.blob); const v=$('#dictVideo'); try{ v.src=url; await v.play().catch(()=>{}); } finally { v.onended=()=>{ try{ URL.revokeObjectURL(url);}catch{} }; } }

  // ===== Admin: main processing =====
  let __processingVideos=false;
  async function processUploadedVideos(){ if(__processingVideos){ log('[중복방지] 이미 처리 중입니다.'); return; } __processingVideos=true; try{ const files=Array.from(adminVideo.files||[]); if(!files.length){ showAlert('영상을 선택하세요','warn'); log('입력 파일 0개 — 중단'); return; } log(`처리 시작: 선택된 파일 ${files.length}개`); let hol; try{ log('Holistic 인스턴스 생성 시도'); hol=await ensureHolAdmin(); log('Holistic 준비 완료'); }catch(e){ showAlert(e.message,'err'); log('Holistic 준비 실패: '+(e?.message||e)); return; } adminLog.textContent=''; if(chkOverlay) chkOverlay.checked=true; let i=0; for(const f of files){ i++; let label=deriveLabel(f.name);
// macOS Unicode normalization & zero-width cleanup
const _N=(s)=> (s&&s.normalize)? s.normalize('NFC') : (s||'');
const _Z=(s)=> _N(String(s)).replace(/[\u200B\u200C\u200D\uFEFF]/g,'').trim();
const rawName=_Z(f.name);
label=_Z(label); log(`[${i}/${files.length}] ▶ ${rawName} → label="${label}"`);
          // ── 사전용 처리: DB에 원본 영상 저장 + 추출은 접미사 제거한 레이블로 계속 ──
          try{
            const mDict = label && label.match(/(.+?)_사전용(?:\s*\(\d+\))?$/u);
            if(mDict){
              const base = (mDict[1]||'').trim();
              try{ await dictPut(base, f); log(`사전용 저장 완료: "${base}"`); }catch(e){ log(`[사전용 저장 실패] ${e&&e.message?e.message:e}`); }
              label = base; // 접미사 제거 후 추출 진행
            }
          }catch(e){ log(`[사전용 처리 오류] ${e&&e.message?e.message:e}`); }
          hol.__firstPass = (i===1);  // mark first sample for forced accept
          const item=await processOne(f,label,hol);
          hol.__firstPass = false; if(item){ log(`저장완료: ${label} frames=${item.frames}, dim=${item.dim}`);} else { log(`스킵: ${label} — 유효 프레임 없음`);} } showAlert(`${files.length}개 처리 완료`,'ok'); } finally { __processingVideos=false; } }

  // ===== Robust processOne (r7.2 consolidated) =====
  if(!window.__processOneVersion || window.__processOneVersion < 72){ window.__processOneVersion = 72; }
  function seekTo(video, t){ return new Promise(res=>{ const on=()=>{ video.removeEventListener('seeked',on); res(); }; video.addEventListener('seeked',on,{once:true}); try{ video.currentTime=t; }catch{ video.removeEventListener('seeked',on); res(); } }); }
  const STRICT = {
      minValidFrames: 40,
      minCoverage: 0.55,
      maxOnset: 0.30,
      minSpan: 0.50,
      minHandsRatio: 0.30
    }

function strictCheck(stats, times, validFlags, handAny, dur){
      const total = stats.f||0;
      const validIdx = validFlags.map((v,i)=> v? i : -1).filter(i=> i>=0);
      const valid = validIdx.length;
      const coverage = total? valid/total : 0;
      const hands = handAny.filter(Boolean).length;
      const handsRatio = total? hands/total : 0;
      let firstT = NaN, lastT = NaN, spanRatio = 0, onsetRatio = 1;
      if(valid){ firstT = times[validIdx[0]]||0; lastT = times[validIdx[validIdx.length-1]]||firstT; }
      if(dur>0 && valid){ spanRatio = (lastT-firstT)/dur; onsetRatio = firstT/dur; }

      const reasons=[];
      if(valid < STRICT.minValidFrames) reasons.push(`유효프레임 부족(${valid}/${STRICT.minValidFrames})`);
      if(coverage < STRICT.minCoverage) reasons.push(`커버리지 부족(${Math.round(coverage*100)}%<${Math.round(STRICT.minCoverage*100)}%)`);
      if(handsRatio < STRICT.minHandsRatio) reasons.push(`손 검출 부족(${Math.round(handsRatio*100)}%<${Math.round(STRICT.minHandsRatio*100)}%)`);
      if(dur>0){
        if(onsetRatio > STRICT.maxOnset) reasons.push(`초기구간 감지 부족(시작 ${Math.round(onsetRatio*100)}%>${Math.round(STRICT.maxOnset*100)}%)`);
        if(spanRatio < STRICT.minSpan) reasons.push(`감지 구간 짧음(${Math.round(spanRatio*100)}%<${Math.round(STRICT.minSpan*100)}%)`);
      }
      return { pass: reasons.length===0, reasons, summary:{total,valid,coverage,handsRatio,firstT,lastT,spanRatio,onsetRatio} };
    }

  async function rescueScan(hol, video, feats, stats, times, validFlags, handAny, opts={}){
      const dur = isFinite(video.duration)?video.duration:0; if(!dur) return false;
      const {mode='uniform', range=[0,1], N=null, reset=false} = opts;
      log(`【구제】 시크 기반 강제 스캔 시작 (mode=${mode}, range=${(range[0]*100|0)}~${(range[1]*100|0)}%)`);
      try{ video.pause(); }catch{}
      // 필요 시 완전 재추출: 기존 누적 버퍼 초기화
      if(reset){ feats.length=0; times.length=0; validFlags.length=0; handAny.length=0; stats.f=stats.p=stats.l=stats.r=stats.d=0; }
      const w=video.videoWidth, h=video.videoHeight; const off=document.createElement('canvas'); off.width=w; off.height=h; const ox=off.getContext('2d',{willReadFrequently:true});
      const [rs,re] = [Math.max(0,range[0]), Math.min(1,range[1])];
      const start = rs*dur, end = Math.max(start, re*dur);
      const targetN = N ?? Math.min(150, Math.max(60, Math.round((end-start)*30))); // 30fps 가정
      const dt = (targetN>1)? (end-start)/(targetN-1) : (end-start);
      for(let i=0;i<targetN;i++){
        const t = Math.min(end, start + i*dt);
        await new Promise(res=>{ const on=()=>{ video.removeEventListener('seeked',on); res(); }; video.addEventListener('seeked',on,{once:true}); try{ video.currentTime=t; }catch{ video.removeEventListener('seeked',on); res(); } });
        ox.drawImage(video, 0, 0, w, h);
        try{ await hol.send({image:off}); }catch{ stats.d++; }
        if(i%15===0) log(`【구제】 진행 ${Math.round((i+1)*100/targetN)}% (t=${t.toFixed(2)}s)`);
        await new Promise(r=>requestAnimationFrame(r));
      }
      log('【구제】 완료');
      return true;
    }
  // === Warmup to stabilize Mediapipe Holistic on first frames ===
async function warmupHolistic(hol, video, frames=18){
  const w = video.videoWidth || 0, h = video.videoHeight || 0;
  if(!w || !h) return;
  const off = document.createElement('canvas'); off.width=w; off.height=h;
  const ctx = off.getContext('2d', { willReadFrequently:true });
  try { if (isFinite(video.duration)) { video.currentTime = Math.min(0.05, video.duration * 0.02); } } catch(e){}
  for(let i=0;i<frames;i++){
    ctx.drawImage(video, 0, 0, w, h);
    try { await hol.send({ image: off }); } catch(e){}
    await new Promise(r=>requestAnimationFrame(r));
  }
}
function processOne(file,label,hol){
  return new Promise(async (resolve)=>{
    // --- state & buffers ---
    let stopped=false, sameCT=0, lastCT=-1, busy=false, sendTimeout=null;
    let rafLogId=0, rafPumpId=0, ivPumpId=0;

    const feats=[];                           // feature vectors
    const stats={f:0,p:0,l:0,r:0,d:0};        // counters
    const times=[];                            // frame times (sec)
    const validFlags=[];                       // any landmark present
    const handAny=[];                          // any hand present

    const clearTimers=()=>{
      try{ cancelAnimationFrame(rafLogId); }catch{}
      try{ cancelAnimationFrame(rafPumpId);}catch{}
      try{ clearInterval(ivPumpId);}catch{}
    };

    const finOnce = async () => {
      if (stopped) return;
      stopped = true;
      clearTimers();

      try { adminPreview.pause(); } catch {}
      try { if (adminPreview.src?.startsWith('blob:')) URL.revokeObjectURL(adminPreview.src); } catch {}

      // quality check using collected per-frame arrays
      const dur = isFinite(adminPreview.duration) ? adminPreview.duration : 0;
      const chk = strictCheck(stats, times, validFlags, handAny, dur); if (!chk.pass) { if (hol && hol.__firstPass) { log('[첫 영상 예외] 품질 기준 미달 → 키프레임 구제 스캔 실행'); try { await rescueIfLowFrames(true); } catch(e){} await new Promise(r=>requestAnimationFrame(()=>requestAnimationFrame(r))); } else { log(`[필터: 스킵] ${chk.reasons.join(' / ')}`); try { resolve(null); } catch {} return; } }

      const seq = downsample(feats, 30);
      if (!seq.length) { try{ resolve(null); }catch{} return; }

      const item = {
        id: crypto.randomUUID(),
        label,
        frames: seq.length,
        dim: seq[0]?.length || 96,
        data: seq,
        added: Date.now(),
      };

      try {
        const ds = loadDS();
        ds.push(item);
        saveDS(ds);
      } catch (e) {
        log('[fin] saveDS 에러: ' + (e?.message || e));
      }

      const pr=(k)=> stats.f ? Math.round(stats[k]*100/stats.f) : 0;
      log(`검출통계: frames=${stats.f}, pose=${pr('p')}%, L=${pr('l')}%, R=${pr('r')}%, drop=${stats.d}`);

      try { resolve(item); } catch {}
    };

    // Low-frame rescue with guarded seek and timeout
    const rescueIfLowFrames = async (force=false) => {
      const dur = isFinite(adminPreview.duration) ? adminPreview.duration : 0;
      if (!force && (stats.f >= 20 || !dur)) return false;

      log('저프레임 감지 — 프레임 스텝 재수집 시작');
      try { adminPreview.pause(); } catch {}
      busy = false;

      const N = 30;
      for (let i = 0; i < N; i++) {
        const t = Math.min(dur - 0.001, (i + 0.5) * dur / N);

        // seek with 300ms timeout
        await new Promise(r=>{
          let done=false;
          const onSeek = () => {
            if (done) return;
            done = true;
            adminPreview.removeEventListener('seeked', onSeek);
            r();
          };
          adminPreview.addEventListener('seeked', onSeek, { once:true });
          try { adminPreview.currentTime = t; } catch { onSeek(); }
          setTimeout(()=>{ if(!done){ log('[구제] seeked 타임아웃 → 계속 진행'); onSeek(); } }, 300);
        });

        try { await hol.send({ image: adminPreview }); } catch { stats.d++; }
        await new Promise(r=>requestAnimationFrame(r));
      }

      log(`재수집 완료: frames≈${stats.f}`);

      // Deadman switch: ensure finishing even if no more events arrive
      setTimeout(()=>{ try{ if(!stopped) finOnce(); }catch(e){ log('[구제 fin] '+(e?.message||e)); } }, 2000);

      return true;
    };

    try{
      // Source prep
      adminPreview.loop=false; adminPreview.src=''; adminPreview.currentTime=0;
      adminPreview.src = URL.createObjectURL(file);

      await new Promise(r=>{ if(adminPreview.readyState>=2) r(); else adminPreview.addEventListener('loadeddata', r, {once:true}); });
      await new Promise(r=>{ if(adminPreview.readyState>=3) r(); else adminPreview.addEventListener('canplay', r, {once:true}); });

      if((adminPreview.currentTime||0)===0){ try{ adminPreview.currentTime=0.001; }catch{} }
      adminPreview.playbackRate=1.0; adminPreview.muted=true; adminPreview.playsInline=true; adminPreview.preload='auto';
      try { await adminPreview.play(); } catch {}

      await new Promise(r=>{ if(!adminPreview.paused) r(); else adminPreview.addEventListener('playing', r, {once:true}); });

      adminCanvas.width = adminPreview.videoWidth;
      adminCanvas.height = adminPreview.videoHeight;

      // Always finalize on end
      adminPreview.addEventListener('ended', onEnded, { once:true });
      async function onEnded(){
        try {
          log('비디오 ended 이벤트 감지');
          clearTimers();

          if (stats.f < 20) {
            await rescueIfLowFrames();
          }

          // flush pending results
          await new Promise(r => requestAnimationFrame(() => requestAnimationFrame(r)));
        } catch (e) {
          log('[ended 핸들러 오류] ' + (e?.message || e));
        } finally {
          finOnce();
        }
      }

      // timeupdate backup pump
      adminPreview.addEventListener('timeupdate', ()=>{ if(!stopped) pump(); });

      // On results: collect features and quality arrays
      hol.onResults((r)=>{
        try {
          syncCanvasToContainer(adminCanvas);
          if(!chkOverlay || chkOverlay.checked) drawOverlay(adminCtx, r, adminPreview, adminCanvas);
        }catch{}

        feats.push(feat(r));
        stats.f++;
        if (r.poseLandmarks) stats.p++;
        if (r.leftHandLandmarks) stats.l++;
        if (r.rightHandLandmarks) stats.r++;

        const t = adminPreview.currentTime || 0;
        times.push(t);
        const hasPose = !!r.poseLandmarks;
        const hasL = !!r.leftHandLandmarks;
        const hasR = !!r.rightHandLandmarks;
        validFlags.push(hasPose || hasL || hasR);
        handAny.push(hasL || hasR);
      });

      const pump = () => {
        if (stopped || busy) return;
        busy = true;
        let settled = false;
        const clear = () => {
          busy = false;
          if (sendTimeout){ clearTimeout(sendTimeout); sendTimeout=null; }
        };
        hol.send({ image: adminPreview })
           .then(()=>{ settled = true; })
           .catch(()=>{ stats.d++; })
           .finally(clear);
        sendTimeout = setTimeout(()=>{ if(!settled){ stats.d++; clear(); } }, 500);
      };

      const dur = isFinite(adminPreview.duration) ? adminPreview.duration : 0;
      const endLikely = () => (adminPreview.currentTime >= dur - 0.033) || (dur && (dur - adminPreview.currentTime) < 0.05);

      if ('requestVideoFrameCallback' in HTMLVideoElement.prototype) {
        const step = () => {
          if (stopped) return;
          const ct = adminPreview.currentTime || 0;
          sameCT = (ct === lastCT) ? sameCT + 1 : 0;
          lastCT = ct;
          pump();
          if (endLikely() && sameCT > 12) {
            log('마지막 프레임 안정화 감지');
            clearTimers();
            if (stats.f < 20) { rescueIfLowFrames().then(finOnce); }
            else { finOnce(); }
            return;
          }
          adminPreview.requestVideoFrameCallback(step);
        };
        adminPreview.requestVideoFrameCallback(step);
      }

      const rafPump = () => { if (stopped) return; pump(); rafPumpId = requestAnimationFrame(rafPump); };
      rafPumpId = requestAnimationFrame(rafPump);
      ivPumpId = setInterval(pump, 33);

      const rafLog = (ts) => {
        if (stopped) return;
        const verbose = !!(chkVerbose?.checked);
        const every = verbose ? 400 : 1200;
        if ((ts % every) < 16) {
          const t = adminPreview.currentTime || 0;
          const pct = dur ? Math.min(100,(t/dur)*100).toFixed(1) : '—';
          const pr=(k)=> stats.f? Math.round(stats[k]*100/stats.f):0;
          log(`진행 ${pct}% t=${t.toFixed(2)}s/${dur?dur.toFixed(2)+'s':'?'} frames=${stats.f} det pose ${pr('p')}% L ${pr('l')}% R ${pr('r')}% drop=${stats.d}`);
        }
        rafLogId = requestAnimationFrame(rafLog);
      };
      rafLogId = requestAnimationFrame(rafLog);

      // Early nudge
      setTimeout(()=>{
        try{
          if(!stopped && stats.f < 6){
            const t = Math.min((adminPreview.currentTime||0)+0.033, Math.max(0,(dur-0.1)));
            adminPreview.currentTime = t;
            log('프레임 저진행 감지 → 시크 너지');
          }
        }catch{}
      }, 900);

    } catch (err) {
      log('에러: ' + (err?.message || err));
      try{ resolve(null); }catch{}
    }
  });
}

  // ===== Mirror toggle (overlay only) =====
  const LS_MIRROR='ksl.mirror.overlay';
  function applyOverlayMirror(on){ const cv=$('#liveCanvas'); const v=$('#liveVideo'); try{ if(cv){ cv.dataset.mirror = on ? '' : 'data'; } if(v){ v.style.transformOrigin='center center'; v.style.transform = on ? 'scaleX(-1)' : ''; } localStorage.setItem(LS_MIRROR, on?'1':'0'); console.log('[KSL] mirror set ->', on, 'dataset:', (cv&&cv.dataset?cv.dataset.mirror:'')); }catch(e){ console.warn('mirror err', e); } }

  // ===== Debug logger (safe, cleaned) =====
  (function(){
    const MAXF=30; const DBG={buf:[], lastLog:0, alpha:null};
    const flatL2=(A,B)=>{ let s=0,c=0; const n=A.length,m=A[0]?.length||0; for(let i=0;i<n;i++){ const a=A[i], b=B[i]||B[Math.min(i,B.length-1)]; for(let j=0;j<m;j++){ const d=(a[j]||0)-(b[j]||0); s+=d*d; c++; } } return Math.sqrt(s/Math.max(1,c)); };
    function computeAlpha(ds){ const by=new Map(); for(const it of ds){ (by.get(it.label)||by.set(it.label,[]).get(it.label)).push(it); } const sample=[]; for(const [,arr] of by){ for(let i=0;i<Math.min(arr.length,4);i++){ for(let j=i+1;j<Math.min(arr.length,5);j++){ sample.push(flatL2(arr[i].data, arr[j].data)); } } } const med=sample.sort((a,b)=>a-b)[Math.floor(sample.length/2)]||1.0; return 1/Math.max(1e-6,med); }
    function debugOnce(seq){ const ds=loadDS(); if(!ds.length) return; if(DBG.alpha==null) DBG.alpha=computeAlpha(ds); const per=new Map(); for(const it of ds){ const d=flatL2(seq,it.data); const cur=per.get(it.label); if(!cur||d<cur.d) per.set(it.label,{d}); } const ranked=[...per.entries()].map(([label,{d}])=>({label,d})).sort((a,b)=>a.d-b.d); const d1=ranked[0]?.d??1e9; const alpha=DBG.alpha; const scores=ranked.map(({label,d})=>({label,s:Math.exp(-alpha*d)})); const Z=scores.reduce((a,b)=>a+b.s,0)||1; const probs=scores.map(({label,s})=>({label,p:s/Z})); const top=probs[0]; if(top){ try{ window.dispatchEvent(new CustomEvent('ksl:recognized',{detail:{label:top.label, score:top.p, source:'debug'}})); }catch{} }
    }
    const prevDraw=drawOverlay; drawOverlay=function(ctx,result,video,canvas){ try{ if(canvas && canvas.id==='liveCanvas'){ const f=feat(result); if(Array.isArray(f)&&f.length){ DBG.buf.push(f); if(DBG.buf.length>MAXF) DBG.buf.shift(); } const t=performance?.now?.()??Date.now(); if(DBG.buf.length>=MAXF && t-DBG.lastLog>400){ DBG.lastLog=t; const seq=downsample(DBG.buf,MAXF); debugOnce(seq); } } }catch{} return prevDraw.apply(this, arguments); };
  })();

  // ===== Safe API (single source of truth) =====
  function makeSafe(){ return {
    tab(key){ try{ const tabs=$$('.tab-btn'); const panels=$$('.tab-panel'); tabs.forEach(b=>{ const on=b.dataset.tab===key; b.setAttribute('aria-selected', on?'true':'false'); }); panels.forEach(p=>{ const on=p.id==='panel-'+key; p.setAttribute('aria-hidden', on?'false':'true'); }); }catch(e){ console.warn('tab err',e);} },
    async startCam(){ try{ await startCamera(); }catch(e){ showAlert(e.message||e,'err'); } },
    async capture(){ try{ if(!cameraLive){ showAlert('먼저 카메라를 켜세요.','warn'); return;} capturing=true; captureBuf=[]; showAlert('3초 캡처 시작…','info'); await new Promise(r=>setTimeout(r,3000)); capturing=false; const seq=downsample(captureBuf,30); if(!seq.length){ showAlert('랜드마크가 감지되지 않았습니다.','warn'); return;} const r=classify(seq); renderPred(r); maybeAwardXP(r.label, Math.round(r.score*100)); }catch(e){ showAlert(e.message||e,'err'); } },
    nextTarget(){ try{ const labels=[...new Set(loadDS().map(x=>x.label))]; if(!labels.length) return; const cur=getTarget(); const i=Math.max(0,labels.indexOf(cur)); setTarget(labels[(i+1)%labels.length]); }catch(e){ console.warn('nextTarget err',e);} },
    quiz(){ try{ const unitId=$('#quizUnit').value; runQuiz(unitId); }catch(e){ showAlert(e.message||e,'err'); } },
    processVideos(){ try{ processUploadedVideos(); }catch(e){ showAlert(e.message||e,'err'); } },
    exportDS(){ try{ const blob=new Blob([JSON.stringify(loadDS(),null,2)],{type:'application/json'}); const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='ksl_dataset.json'; a.click(); }catch(e){ showAlert(e.message||e,'err'); } },
    refreshDS(){ try{ refreshDatasetList(); }catch(e){ console.warn('refreshDS err',e);} },
    clearDS(){ try{ if(confirm('정말 전체 삭제할까요?')){ localStorage.setItem(DS_KEY,'[]'); refreshDatasetList(); buildLessonUnits(); refreshLabelList(); showAlert('데이터셋 초기화 완료','ok'); } }catch(e){ showAlert(e.message||e,'err'); } },
    clearLog(){ try{ adminLog.textContent=''; }catch(e){ console.warn('clearLog err',e);} }
  }; }

  
function bindUI(){
  const SEL='[data-action], .tab-btn, #btnStartCam, #btnCapture, #btnNextTarget, #btnStartQuiz, #btnProcessVideo, #btnExport, #btnRefreshDS, #btnClearDS, #btnClearLog, #btnMode, #dictClear, #dictSearch';
  const delegate = (ev) => {
    const t = ev.target.closest(SEL);
    if(!t) return;
    if(ev.type==='keyup' && !(ev.key==='Enter'||ev.key===' ')) return;

    try{
      if(t.id==='btnMode'){ document.documentElement.setAttribute('data-mode', document.documentElement.getAttribute('data-mode')==='vivid'?'default':'vivid'); return; }
      if(t.dataset?.tab){ __callSafe('tab', t.dataset.tab); return; }
      if(t.id==='btnStartCam') return __callSafe('startCam');
      if(t.id==='btnCapture') return __callSafe('capture');
      if(t.id==='btnNextTarget') return __callSafe('nextTarget');
      if(t.id==='btnStartQuiz') return __callSafe('quiz');
      if(t.id==='btnProcessVideo') return __callSafe('processVideos');
      if(t.id==='btnExport') return __callSafe('exportDS');
      if(t.id==='btnRefreshDS') return __callSafe('refreshDS');
      if(t.id==='btnClearDS') return __callSafe('clearDS');
      if(t.id==='btnClearLog') return __callSafe('clearLog');
      if(t.dataset.action==='set-target'){ setTarget(t.dataset.label); showAlert(`목표를 "${t.dataset.label}"(으)로 설정했습니다.`,'info'); return; }
      if(t.dataset.action==='quiz-from-unit'){ runQuiz(t.dataset.unit); return; }
      if(t.dataset.action==='play-dict'){ playDict(t.dataset.label); return; }
      if(t.id==='dictClear'){ const input=$('#dictSearch'); if(input){ input.value=''; renderDictList(''); } return; }
    }catch(e){ console.warn('delegate err',e); }
  };
  ['click','keyup'].forEach(evt=>document.addEventListener(evt, delegate, true));

  // Mirror toggle wiring
  try{
    const mirrorChk=$('#mirrorChk');
    const wrap = $('#mirrorToggleWrap');
    const sw = wrap ? wrap.querySelector('.switch') : null;
    const lbl = $('#mirrorLbl');
    const updateAria = (on)=>{ if(sw){ sw.setAttribute('aria-checked', on ? 'true' : 'false'); } };
    const toggleMirror = ()=>{ if(!mirrorChk) return; mirrorChk.checked = !mirrorChk.checked; updateAria(mirrorChk.checked); applyOverlayMirror(mirrorChk.checked); };
    if(sw){
      sw.setAttribute('tabindex','0');
      sw.addEventListener('click', (e)=>{ e.preventDefault(); toggleMirror(); }, true);
      sw.addEventListener('keyup', (e)=>{ if(e.key==='Enter'||e.key===' '){ e.preventDefault(); toggleMirror(); } }, true);
    }
    if(lbl){ lbl.addEventListener('click', (e)=>{ e.preventDefault(); toggleMirror(); }, true); }
    if(mirrorChk) updateAria(mirrorChk.checked);
  }catch(e){ console.warn('mirror wiring err', e); }

  // Direct bindings for critical buttons (fallback if delegation fails)
  try{
    const ids = ['btnProcessVideo','btnStartCam','btnCapture','btnNextTarget','btnStartQuiz','btnExport','btnRefreshDS','btnClearDS','btnClearLog','tabbtn-learn','tabbtn-lessons','tabbtn-admin','btnMode'];
    const map = {
      'btnProcessVideo': ()=> __callSafe('processVideos'),
      'btnStartCam': ()=> __callSafe('startCam'),
      'btnCapture': ()=> __callSafe('capture'),
      'btnNextTarget': ()=> __callSafe('nextTarget'),
      'btnStartQuiz': ()=> __callSafe('quiz'),
      'btnExport': ()=> __callSafe('exportDS'),
      'btnRefreshDS': ()=> __callSafe('refreshDS'),
      'btnClearDS': ()=> __callSafe('clearDS'),
      'btnClearLog': ()=> __callSafe('clearLog'),
      'tabbtn-learn': ()=> __callSafe('tab','learn'),
      'tabbtn-lessons': ()=> __callSafe('tab','lessons'),
      'tabbtn-admin': ()=> __callSafe('tab','admin'),
      'btnMode': ()=> { const m=document.documentElement.getAttribute('data-mode')==='vivid'?'default':'vivid'; document.documentElement.setAttribute('data-mode', m); }
    };
    ids.forEach(id=>{
      const el = document.getElementById(id);
      if(!el) return;
      el.addEventListener('click', (ev)=>{ ev.stopPropagation(); try{ map[id](); }catch(e){ console.warn('direct click err', e); } }, true);
    });
  }catch(e){ console.warn('direct bind err', e); }

  // Global click logger (for debugging)
  try{
    document.addEventListener('click', (e)=>{
      try{
        const t = e.target;
        const info = `[click] id=${t.id||'-'} tag=${t.tagName} class=${(t.className||'').toString().slice(0,80)}`;
        if (typeof log === 'function') log(info); else console.log(info);
      }catch{}
    }, true);
  }catch{}

  // JSON import handler (merge + dedupe)
  try{
    const inp = document.getElementById('importJson');
    if(inp){
      inp.addEventListener('change', async ()=>{
        try{
          const f = inp.files && inp.files[0];
          if(!f){ showAlert('가져올 .json 파일을 선택하세요','warn'); return; }
          const text = await f.text();
          let raw=null; try{ raw=JSON.parse(text); }catch(e){ showAlert('JSON 파싱 실패','err'); log('[가져오기 실패] '+(e?.message||e)); return; }
          let arr = Array.isArray(raw)? raw : (
            Array.isArray(raw.dataset)? raw.dataset :
            Array.isArray(raw.items)? raw.items :
            Array.isArray(raw.ds)? raw.ds :
            (raw && Array.isArray(raw.data)? raw.data : [])
          );
          if(!arr.length){ showAlert('유효한 데이터셋이 아닙니다','err'); return; }
          const now = Date.now(); const norm=[];
          for(const it of arr){
            if(!it) continue;
            const label = String(it.label || it.name || it.word || it.title || '').trim();
            let data = it.data || it.seq || it.sequence || it.samples;
            if(!Array.isArray(data)) continue;
            data = data.filter(fr=>Array.isArray(fr)).map(fr=>fr.map(x=>+x||0));
            if(!data.length) continue;
            const dim = it.dim || (data[0]?.length||0);
            const frames = it.frames || data.length;
            const id = it.id || (crypto?.randomUUID? crypto.randomUUID() : ('imp_'+Math.random().toString(36).slice(2)));
            const added = it.added || now;
            norm.push({ id, label: label || '(무명)', frames, dim, data, added });
          }
          if(!norm.length){ showAlert('가져올 항목이 없습니다','warn'); return; }
          const ex = loadDS();
          const ids = new Set(ex.map(x=>x.id));
          const keys = new Set(ex.map(x=>x.label+'|'+x.frames+'|'+x.dim));
          let addedCnt=0;
          for(const it of norm){
            const key = it.label+'|'+it.frames+'|'+it.dim;
            if(ids.has(it.id) || keys.has(key)) continue;
            ex.push(it); ids.add(it.id); keys.add(key); addedCnt++;
          }
          saveDS(ex);
          showAlert(`가져오기 완료: ${addedCnt}개 추가`,'ok');
          try{ inp.value=''; }catch{}
        }catch(e){ showAlert('가져오기 중 오류','err'); log('[가져오기 오류] '+(e?.message||e)); }
      });
    }
  }catch(e){ console.warn('import bind err', e); }

}


  // ===== Bootstrap =====
  window.addEventListener('DOMContentLoaded', async ()=>{
    window.__safe = makeSafe();
    (window.__pending_calls||[]).splice(0).forEach(([name,args])=>{ try{ const fn=window.__safe[name]; typeof fn==='function' && fn.apply(null,args); }catch(e){} });
    bindUI(); refreshDatasetList(); buildLessonUnits(); refreshLabelList(); renderXP();
    // restore mirror state
    const on = localStorage.getItem(LS_MIRROR)==='1'; const chk=$('#mirrorChk'); if(chk){ chk.checked=on; applyOverlayMirror(on); }
    // initial dict list
    try{ await renderDictList(''); }catch{}
    console.log('[KSL] ready (KRDS 스타일, 정리본 r8)');
  });
  </script>
</body>
</html>
