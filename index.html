<!doctype html>
<html lang="ko" data-mode="default">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Handy! Â· ëª¨ì…˜ ì¸ì‹ ìˆ˜í™” í•™ìŠµ ì„œë¹„ìŠ¤</title>
  
  <!-- ===================== Safe stub & MediaPipe base ===================== -->
  <script>
    (function(){
      const q=[]; window.__pending_calls=q;
      window.__safe = new Proxy({}, { get(_t,prop){ if(prop==='then') return undefined; return (...args)=>q.push([prop,args]); }});
      window.__callSafe = function(name, ...args){ try{ const s=window.__safe; if(s && typeof s[name]==='function') return s[name](...args); q.push([name,args]); }catch(e){ console.warn('callSafe',e);} };
      // MediaPipe local base (adjust if needed)
      window.MP_BASE='libs/mediapipe';
      window.LOCATE_HOLISTIC=(f)=> `${MP_BASE}/holistic/${f}`;
    })();
  </script>
  
  <!-- ===================== MediaPipe (local bundles) ===================== -->
  <script src="libs/mediapipe/holistic/holistic.js"></script>
  <script src="libs/mediapipe/camera_utils/camera_utils.js"></script>
  <script src="libs/mediapipe/drawing_utils/drawing_utils.js"></script>

  <!-- ===================== KRDS-ish minimal design tokens ===================== -->
  <style>
    :root{
      /* Grays */
      --bg:#f6f7f9; --surface:#ffffff; --surface-2:#f3f4f6; --border:#e5e7eb; --ink:#0f172a; --ink-2:#334155;
      /* Primary */
      --primary-600:#0b4da2; --primary-700:#083e82; --primary-50:#e7eef7; --ring: var(--primary-600);
      /* System */
      --success-600:#16a34a; --warning-600:#d97706; --danger-600:#dc2626; --info-600:#2563eb;
      --radius:12px; --radius-lg:16px;
    }
    html[data-mode="vivid"]{ --bg:#0b1220; --surface:#0f172a; --surface-2:#111827; --border:#334155; --ink:#e5e7eb; --ink-2:#cbd5e1; --primary-600:#4f9cff; --primary-700:#1e7fe8; --primary-50:#0b1220; --ring:#93c5fd; }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0; font-family:Pretendard, "Pretendard GOV", system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans KR", Arial, sans-serif; background:var(--bg); color:var(--ink)}
    a{color:var(--primary-600); text-decoration:none} a:hover{text-decoration:underline}

    header{position:sticky; top:0; z-index:50; background:var(--surface); border-bottom:1px solid var(--border); backdrop-filter:saturate(180%) blur(6px)}
    main{max-width:1200px; margin:0 auto; padding:16px}
    .brand{font-weight:900; letter-spacing:-0.01em}

    .card{ background:var(--surface); border:1px solid var(--border); border-radius:var(--radius-lg); box-shadow:0 1px 2px rgba(0,0,0,.04); padding:16px }
    .muted{ color:var(--ink-2) }

    .btn{ --_bg:#111827; --_fg:#fff; --_bd:var(--border); border:1px solid var(--_bd); background:var(--_bg); color:var(--_fg); border-radius:var(--radius); padding:10px 14px; font-weight:700; cursor:pointer; line-height:1; display:inline-flex; align-items:center; gap:8px; letter-spacing:-0.01em }
    .btn:focus-visible{ outline:3px solid var(--ring); outline-offset:2px }
    .btn:hover{ filter:brightness(0.96) }
    .btn--primary{ --_bg:var(--primary-600); --_bd:var(--primary-700) }
    .btn--secondary{ --_bg:#fff; --_fg:#111827 }
    .btn--ghost{ --_bg:transparent; --_fg:var(--ink) }
    .btn[disabled]{ opacity:.5; cursor:not-allowed }

    .tabs{ display:flex; gap:6px }
    .tab-btn{ appearance:none; background:transparent; border:1px solid transparent; color:var(--ink-2); padding:10px 14px; border-radius:10px; font-weight:700; cursor:pointer }
    .tab-btn[aria-selected="true"]{ color:var(--ink); background:var(--surface-2); border-color:var(--border) }
    .tab-panel{ display:none }
    .tab-panel[aria-hidden="false"]{ display:block }

    .row{ display:flex; align-items:center; justify-content:space-between; gap:12px }

    .slot{ position:relative; aspect-ratio:16/9; background:#0001; border:1px solid var(--border); border-radius:12px; overflow:hidden }
    .slot > video, .slot > canvas{ position:absolute; inset:0; width:100%; height:100% }
.slot > video{ z-index:1 }
.slot > canvas{ z-index:2; pointer-events:none !important }
.slot > canvas{ pointer-events:none !important; }
.slot > canvas{ pointer-events:none !important }
    /*__overlay_zindex__*/
    .slot > video{ z-index:1 }
    .slot > canvas{ z-index:2 }
    .slot > video{ object-fit:contain; background:#000 }
    .slot > canvas{ pointer-events:none }

    ul.clean{ list-style:none; padding:0; margin:0 }

    #alert{ display:none; margin-top:12px; padding:10px 12px; border-radius:12px; border:1px solid var(--border) }
    #alert.show{ display:block }

    /* Mirror toggle (overlay only) */
    .mirror-toggle{ display:flex; align-items:center; gap:8px; margin:10px 8px 0; font-size:14px; color:#334155; user-select:none }
    .mirror-toggle .switch{ position:relative; width:44px; height:24px; background:#e5e7eb; border-radius:9999px; display:inline-block; vertical-align:middle; box-shadow:inset 0 0 0 1px #d1d5db; transition:background .2s ease; cursor:pointer }
    .mirror-toggle .switch::after{ content:""; position:absolute; top:2px; left:2px; width:20px; height:20px; border-radius:9999px; background:#fff; box-shadow:0 1px 2px rgba(0,0,0,.2); transition:transform .2s ease }
    .mirror-toggle input:checked + .switch{ background:#2563eb }
    .mirror-toggle input:checked + .switch::after{ transform:translateX(20px) }
    .mirror-toggle .label{ font-weight:600 }
  </style>
</head>
<body>
  <!-- ===================== Header ===================== -->
  <header>
    <div style="max-width:1200px;margin:0 auto;padding:12px 16px;display:flex;align-items:center;justify-content:space-between;gap:12px;">
      <div class="brand">Handy!</div>
      <nav role="tablist" aria-label="ì£¼ íƒ­" class="tabs">
        <button class="tab-btn" role="tab" id="tabbtn-learn" aria-controls="panel-learn" aria-selected="true" data-tab="learn">í•™ìŠµ</button>
        <button class="tab-btn" role="tab" id="tabbtn-lessons" aria-controls="panel-lessons" aria-selected="false" data-tab="lessons">ë ˆìŠ¨</button>
        <button class="tab-btn" role="tab" id="tabbtn-admin" aria-controls="panel-admin" aria-selected="false" data-tab="admin">ê´€ë¦¬ì</button>
      </nav>
      <div style="display:flex;gap:8px;align-items:center;">
        <button id="btnMode" class="btn btn--secondary" title="ì„ ëª…í•œ í™”ë©´ ëª¨ë“œ í† ê¸€">ì„ ëª… ëª¨ë“œ</button>
      </div>
    </div>
  </header>

  <!-- ===================== Main ===================== -->
  <main>
    <div id="alert" class="card"></div>

    <!-- ===== Learn ===== -->
    <section id="panel-learn" class="tab-panel" role="tabpanel" aria-labelledby="tabbtn-learn" aria-hidden="false">
      <div style="display:grid;grid-template-columns:1.1fr 1.4fr;gap:16px;">
        <!-- Left: Dictionary -->
        <div class="card" id="dictCard">
          <div class="row">
            <h2 style="margin:0">ìˆ˜ì–´ ì‚¬ì „</h2>
            <small class="muted">ê´€ë¦¬ìì—ì„œ <b>ë‹¨ì–´ëª…_ì‚¬ì „ìš©</b>ìœ¼ë¡œ ì—…ë¡œë“œí•œ ì˜ìƒ</small>
          </div>

          <div class="row" style="gap:8px;margin-top:8px;">
            <input id="dictSearch" class="btn btn--ghost" placeholder="ë‹¨ì–´ ê²€ìƒ‰â€¦" style="flex:1;border:1px solid var(--border);background:var(--surface);" />
            <button id="dictClear" class="btn">ì§€ìš°ê¸°</button>
          </div>

          <div class="slot" style="margin-top:10px;">
            <video id="dictVideo" controls playsinline preload="metadata"></video>
          </div>

          <ul id="dictList" class="clean" style="margin-top:10px;display:grid;gap:8px;max-height:220px;overflow:auto;"></ul>
        </div>

        <!-- Right: Live recognition -->
        <div style="display:grid;grid-template-rows:auto auto 1fr;gap:16px;">
          <div class="card" id="liveCard">
            <div class="row">
              <h2 style="margin:0">ì‹¤ì‹œê°„ ì¸ì‹</h2>
              <div style="display:flex;gap:8px;flex-wrap:wrap">
                <button id="btnStartCam" class="btn btn--primary">ì¹´ë©”ë¼ ì¼œê¸°</button>
                <button id="btnCapture" class="btn">3ì´ˆ ìº¡ì²˜</button>
              </div>
            </div>
            <div class="slot" style="margin-top:10px;">
              <video id="liveVideo" playsinline muted></video>
              <canvas id="liveCanvas"></canvas>
            </div>
            <div class="mirror-toggle" id="mirrorToggleWrap">
              <input id="mirrorChk" type="checkbox" style="display:none" />
              <span class="switch" role="switch" aria-labelledby="mirrorLbl"></span>
              <span class="label" id="mirrorLbl">ê±°ìš¸ëª¨ë“œ(ì˜¤ë²„ë ˆì´ë§Œ)</span>
            </div>
            <div style="display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-top:10px;">
              <div class="card" style="padding:12px;">
                <div class="muted" style="font-size:12px;">ì˜ˆì¸¡ ë ˆì´ë¸”</div>
                <div id="predLabel" style="font-weight:900;font-size:24px;">â€”</div>
              </div>
              <div class="card" style="padding:12px;">
                <div class="muted" style="font-size:12px;">ì •í™•ë„(ìœ ì‚¬ë„)</div>
                <div><span id="predScore" style="font-weight:900;font-size:24px;">â€”</span><span class="muted"> / 100</span></div>
              </div>
            </div>
            <div style="margin-top:10px;">
              <div class="muted" style="font-size:12px;">Top-3</div>
              <ul id="topk" class="clean" style="margin-top:6px;display:grid;gap:4px;"></ul>
            </div>
          </div>

          <div class="card">
            <h3 style="margin:0">ì˜¤ëŠ˜ì˜ ë¯¸ì…˜</h3>
            <div class="card" style="margin-top:8px;">
              <div class="muted" style="font-size:12px;">ëª©í‘œ ë ˆì´ë¸”</div>
              <div class="row" style="margin-top:6px;">
                <div id="targetLabel" style="font-weight:900;font-size:20px;">â€”</div>
                <button id="btnNextTarget" class="btn">ë‹¤ë¥¸ ëª©í‘œ</button>
              </div>
            </div>
            <div style="margin-top:12px;">
              <div class="row muted"><span>XP ì§„í–‰ë„</span><span id="xpText">0 / 100</span></div>
              <div style="height:8px;border-radius:999px;background:var(--surface-2);overflow:hidden;margin-top:6px;">
                <div id="xpBar" style="height:100%;width:0%;background:var(--primary-600);"></div>
              </div>
              <div id="badgeArea" class="muted" style="margin-top:8px;font-size:12px;"></div>
            </div>
          </div>

          <div class="card">
            <h3 style="margin:0">ë°ì´í„°ì…‹ ë ˆì´ë¸”</h3>
            <ul id="labelList" class="clean" style="margin-top:8px;display:grid;gap:6px;"></ul>
          </div>
        </div>
      </div>
    </section>

    <!-- ===== Lessons ===== -->
    <section id="panel-lessons" class="tab-panel" role="tabpanel" aria-labelledby="tabbtn-lessons" aria-hidden="true">
      <div class="card">
        <h2 style="margin:0">ë ˆìŠ¨ (ê¸°ì´ˆ â†’ ìƒí™©ë³„ í‘œí˜„)</h2>
        <p class="muted" style="margin:6px 0 0 0">ì—…ë¡œë“œëœ ë ˆì´ë¸”ì„ ê¸°ë°˜ìœ¼ë¡œ ì´ìš© ê°€ëŠ¥ ì—¬ë¶€ë¥¼ í‘œì‹œí•©ë‹ˆë‹¤.</p>
        <div id="lessonUnits" style="margin-top:10px;display:grid;grid-template-columns:1fr 1fr;gap:12px;"></div>
      </div>
      <div class="card" style="margin-top:12px;display:flex;gap:8px;align-items:center;">
        <select id="quizUnit" class="btn btn--ghost" style="border:1px solid var(--border);background:var(--surface);"></select>
        <button id="btnStartQuiz" class="btn btn--primary">í€´ì¦ˆ ì‹œì‘</button>
        <span id="quizPrompt" class="muted"></span>
      </div>
    </section>

    <!-- ===== Admin ===== -->
    <section id="panel-admin" class="tab-panel" role="tabpanel" aria-labelledby="tabbtn-admin" aria-hidden="true">
      <div style="display:grid;grid-template-columns:1.7fr 1fr;gap:16px;">
        <div class="card">
          <h2 style="margin:0">ì˜ìƒ ì—…ë¡œë“œ & ëœë“œë§ˆí¬ ì¶”ì¶œ</h2>
          <p class="muted" style="margin:6px 0 0 0">ì—¬ëŸ¬ íŒŒì¼ ì„ íƒ ì‹œ ì¼ê´„ ì²˜ë¦¬. <b>íŒŒì¼ëª… = ë ˆì´ë¸”</b> (ì˜ˆ: <code>ê°ì‚¬í•©ë‹ˆë‹¤_ì‚¬ì „ìš©.mp4</code>)</p>
          <div style="margin-top:10px;"><input id="adminVideo" type="file" accept="video/*" multiple /></div>
          <div style="margin-top:8px;display:flex;gap:8px;flex-wrap:wrap">
            <button id="btnProcessVideo" class="btn btn--primary">ì¶”ì¶œ & ì €ì¥</button>
            <button id="btnExport" class="btn">ë°ì´í„°ì…‹ ë‚´ë³´ë‚´ê¸°</button>
            <label class="btn btn--secondary" style="cursor:pointer;">
              ë°ì´í„°ì…‹ ê°€ì ¸ì˜¤ê¸° <input id="importJson" type="file" accept="application/json" hidden />
            </label>
          </div>
          <div style="margin-top:6px;display:flex;gap:12px;align-items:center;" class="muted">
            <label><input id="chkVerbose" type="checkbox" checked /> ìƒì„¸ ë¡œê·¸</label>
            <label><input id="chkOverlay" type="checkbox" checked /> ë¶„ì„ ì˜¤ë²„ë ˆì´</label>
            <button id="btnClearLog" class="btn btn--ghost" style="border:1px solid var(--border);">ë¡œê·¸ ì§€ìš°ê¸°</button>
          </div>
          <div style="margin-top:10px;">
            <div class="slot">
              <video id="adminPreview" playsinline muted preload="auto" autoplay></video>
              <canvas id="adminCanvas"></canvas>
            </div>
            <pre id="adminLog" class="card" style="margin-top:8px;white-space:pre-wrap;height:180px;overflow:auto;font:12px/1.35 ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;"></pre>
          </div>
        </div>
        <div class="card">
          <h3 style="margin:0">ë°ì´í„°ì…‹</h3>
          <p class="muted" style="margin:6px 0 0 0">ë¸Œë¼ìš°ì €(LocalStorage)ì— ì €ì¥ë©ë‹ˆë‹¤.</p>
          <div style="margin-top:8px;display:flex;gap:8px;flex-wrap:wrap">
            <button id="btnRefreshDS" class="btn btn--secondary">ìƒˆë¡œê³ ì¹¨</button>
            <button id="btnClearDS" class="btn" style="background:var(--danger-600);border-color:#b91c1c;">ì „ì²´ ì‚­ì œ</button>
          </div>
          <ul id="datasetList" class="clean" style="margin-top:10px;display:grid;gap:8px;"></ul>
        </div>
      </div>
    </section>
  </main>

  <!-- ===================== Scripts ===================== -->
  <script>
  // ===== Utilities =====
  const $=(s)=>document.querySelector(s), $$=(s)=>Array.from(document.querySelectorAll(s));
  const alertBox = $('#alert');
  function showAlert(msg, kind='info'){
    const map={info:'var(--info-600)', ok:'var(--success-600)', warn:'var(--warning-600)', err:'var(--danger-600)'};
    alertBox.textContent=msg; alertBox.classList.add('show');
    alertBox.style.boxShadow=`inset 0 0 0 2px ${map[kind]||map.info}33`;
    setTimeout(()=>alertBox.classList.remove('show'), 3000);
  }

  // ===== Storage keys =====
  const DS_KEY='ksl_dataset_v8', XP_KEY='ksl_xp_v8', TARGET_KEY='ksl_target_v8';
  const DICT_DB='ksl_dict_v1', DICT_STORE='videos';

  // ===== Dataset storage (LocalStorage) =====
  const loadDS=()=>{ try{return JSON.parse(localStorage.getItem(DS_KEY)||'[]');}catch{return []} };
  const saveDS=(ds)=>{ localStorage.setItem(DS_KEY, JSON.stringify(ds)); refreshDatasetList(); buildLessonUnits(); refreshLabelList(); };
  const getXP=()=>parseInt(localStorage.getItem(XP_KEY)||'0',10), setXP=(v)=>{ localStorage.setItem(XP_KEY,String(v)); renderXP(); };
  const getTarget=()=>localStorage.getItem(TARGET_KEY)||'â€”', setTarget=(l)=>{ localStorage.setItem(TARGET_KEY,l); const t=$('#targetLabel'); if(t) t.textContent=l; };

  function renderXP(){ const xp=getXP(); $('#xpText').textContent=`${xp} / 100`; $('#xpBar').style.width=Math.min(100,xp)+'%'; const b=$('#badgeArea'); b.innerHTML=''; if(xp>=20)b.innerHTML+='<div>ğŸ¥‰ Newbie</div>'; if(xp>=50)b.innerHTML+='<div>ğŸ¥ˆ Apprentice</div>'; if(xp>=100)b.innerHTML+='<div>ğŸ¥‡ Master</div>'; }
  function maybeAwardXP(pred,score){ const t=getTarget(); if(!t||t==='â€”')return; if(pred===t && score>=70){ const add=10+Math.round((score-70)/3); setXP(Math.min(100,getXP()+add)); showAlert(`ëª©í‘œ ì„±ê³µ! +${add} XP`,'ok'); } }

  // ===== Lessons =====
  const LESSON_PLAN=[
    {id:'u0', title:'ê¸°ì´ˆ ì¸ì‚¬', items:['ì•ˆë…•í•˜ì„¸ìš”','ê°ì‚¬í•©ë‹ˆë‹¤','ë¯¸ì•ˆí•©ë‹ˆë‹¤','ì˜ê°€ìš”']},
    {id:'u1', title:'ìê¸°ì†Œê°œ', items:['ì´ë¦„','ë‚˜ë¼','ë‚˜ì´','ì§ì—…']},
    {id:'u2', title:'ìˆ«ìÂ·ì‹œê°„', items:['í•˜ë‚˜','ë‘˜','ì…‹','ëª‡ ì‹œ','ì˜¤ëŠ˜']},
    {id:'u3', title:'ì¼ìƒ í•„ìˆ˜', items:['ë¬¼','ë°¥','í™”ì¥ì‹¤','ë„ì™€ì£¼ì„¸ìš”']},
    {id:'u4', title:'ì‡¼í•‘', items:['ì–¼ë§ˆì˜ˆìš”','ì‹¸ê²Œ','ì¹´ë“œ','ì˜ìˆ˜ì¦']},
    {id:'u5', title:'ê¸¸ì°¾ê¸°', items:['ì–´ë””','ì˜¤ë¥¸ìª½','ì™¼ìª½','ì§€í•˜ì² ']},
    {id:'u6', title:'ê¸´ê¸‰ ìƒí™©', items:['ìœ„í—˜','ë³‘ì›','ê²½ì°°']}
  ];

  function buildLessonUnits(){ const ds=loadDS(); const labels=new Set(ds.map(x=>x.label)); const wrap=$('#lessonUnits'); if(!wrap) return; wrap.innerHTML=''; LESSON_PLAN.forEach(u=>{ const card=document.createElement('div'); card.className='card'; const avail=u.items.filter(t=>labels.has(t)); const html=`<div class='row'><div class='font-semibold'>${u.title}</div><button class='btn' data-action='quiz-from-unit' data-unit='${u.id}'>í€µ í€´ì¦ˆ</button></div><div class='muted' style='margin-top:6px;font-size:14px;'><div class='font-medium'>í•™ìŠµ ê°€ëŠ¥ (${avail.length}/${u.items.length})</div><ul class='clean' style='margin-top:6px;display:grid;gap:4px;'>${u.items.map(t=>{ const has=labels.has(t); const status=has? '<span style="color:var(--success-600)">ì‚¬ìš© ê°€ëŠ¥</span>' : '<span class="muted">ìƒ˜í”Œ ì—†ìŒ</span>'; const btn=has? `<button class='btn btn--ghost' style='border:1px solid var(--border);padding:4px 8px;font-size:12px' data-action='set-target' data-label='${t}'>ëª©í‘œë¡œ</button>`:''; return `<li class='row'>â€¢ ${t}<span>${status}</span>${btn}</li>`; }).join('')}</ul></div>`; card.innerHTML=html; wrap.appendChild(card); }); const sel=$('#quizUnit'); if(sel){ sel.innerHTML=''; LESSON_PLAN.forEach(u=>{ const op=document.createElement('option'); op.value=u.id; op.textContent=u.title; sel.appendChild(op); }); } }
  function runQuiz(unitId){ const unit=LESSON_PLAN.find(u=>u.id===unitId)||LESSON_PLAN[0]; const labels=new Set(loadDS().map(x=>x.label)); const candidates=(unit?.items||[]).filter(l=>labels.has(l)); const el=$('#quizPrompt'); if(!candidates.length){ el.textContent='ì´ ìœ ë‹›ì—” ì‚¬ìš© ê°€ëŠ¥í•œ ë ˆì´ë¸”ì´ ì—†ìŠµë‹ˆë‹¤.'; return; } const pick=candidates[Math.floor(Math.random()*candidates.length)]; setTarget(pick); el.textContent=`ëª©í‘œ: ${pick} â€” 3ì´ˆ ìº¡ì²˜ë¥¼ ëˆŒëŸ¬ ë§ì¶°ë³´ì„¸ìš”!`; }

  // ===== Dataset UI =====
  function refreshDatasetList(){ const ds=loadDS(); const ul=$('#datasetList'); if(!ul) return; if(!ds.length){ ul.innerHTML='<li class="muted">ë°ì´í„°ì…‹ ì—†ìŒ</li>'; return; } ul.innerHTML=''; ds.forEach((it,i)=>{ const li=document.createElement('li'); li.className='card'; li.innerHTML=`<div class='row'><div><div class='font-semibold'>[#${i+1}] ${it.label}</div><div class='muted' style='font-size:12px'>frames:${it.frames}, dim:${it.dim}, added:${new Date(it.added).toLocaleString()}</div></div><button class='btn btn--ghost' style='border:1px solid var(--border);' data-del='${it.id}'>ì‚­ì œ</button></div>`; ul.appendChild(li); }); ul.querySelectorAll('[data-del]').forEach(b=>b.addEventListener('click',()=>{ const id=b.dataset.del; const nd=loadDS().filter(x=>x.id!==id); saveDS(nd); showAlert('ì‚­ì œ ì™„ë£Œ','ok'); })); }
  function refreshLabelList(){ const ds=loadDS(); const labels=[...new Set(ds.map(x=>x.label))].sort(); const ul=$('#labelList'); if(!ul) return; ul.innerHTML = labels.length ? labels.map(l=>`<li><button class='btn btn--ghost' style='border:1px solid var(--border);padding:4px 8px;font-size:12px' data-action='set-target' data-label='${l}'>${l}</button></li>`).join('') : '<li class="muted">ë°ì´í„°ì…‹ì´ ë¹„ì–´ ìˆìŠµë‹ˆë‹¤.</li>'; if(labels.length && getTarget()==='â€”') setTarget(labels[0]); else $('#targetLabel').textContent=getTarget(); }

  // ===== Feature extraction =====
  const POSE_IDXS=[11,12,13,14,15,16];
  const normPose=(lm)=>{ const L=lm?.[11],R=lm?.[12]; if(!L||!R) return new Array(12).fill(0); const o={x:(L.x+R.x)/2,y:(L.y+R.y)/2}; const s=Math.max(1e-6,Math.hypot(L.x-R.x,L.y-R.y)); const out=[]; for(const i of POSE_IDXS){ const p=lm?.[i]; out.push(p? (p.x-o.x)/s:0, p? (p.y-o.y)/s:0);} return out; };
  const normHand=(h)=>{ if(!h||!h.length) return new Array(42).fill(0); const w=h[0]; const m=h[5]||w; const s=Math.max(1e-6,Math.hypot(m.x-w.x,m.y-w.y)); const out=[]; for(const p of h){ out.push((p.x-w.x)/s,(p.y-w.y)/s);} while(out.length<42) out.push(0); return out.slice(0,42); };
  const feat=(r)=> normPose(r.poseLandmarks).concat(normHand(r.leftHandLandmarks), normHand(r.rightHandLandmarks));
  const downsample=(seq,t=30)=>{ if(seq.length<=t) return seq.slice(); const out=[]; const step=seq.length/t; for(let i=0;i<t;i++) out.push(seq[Math.floor(i*step)]); return out; };
  const dist=(a,b)=>{ let s=0; for(let i=0;i<a.length;i++){ const d=a[i]-b[i]; s+=d*d;} return Math.sqrt(s); };
  const dtw=(A,B)=>{ const n=A.length,m=B.length,INF=1e15; const dp=Array.from({length:n+1},()=>new Float64Array(m+1).fill(INF)); dp[0][0]=0; for(let i=1;i<=n;i++){ for(let j=1;j<=m;j++){ const c=dist(A[i-1],B[j-1]); const b=Math.min(dp[i-1][j],dp[i][j-1],dp[i-1][j-1]); dp[i][j]=c+b; }} return dp[n][m]/(n+m); };
// === Robust helpers ===
// sumAbsRange: sum of absolute values in [s, e)
function sumAbsRange(v, s, e){ let t=0; for(let i=s;i<e;i++) t += Math.abs(v[i]||0); return t; }
// hands present?
function isHandsFrame(vec){
  const L = sumAbsRange(vec, 12, 54);
  const R = sumAbsRange(vec, 54, 96);
  return (L + R) > 1e-3;
}
// crop to active window where hands are present (with small padding)
function cropActive(seq){
  try{
    const idx=[]; for(let i=0;i<seq.length;i++){ if(isHandsFrame(seq[i])) idx.push(i); }
    if(!idx.length) return seq.slice();
    let a=idx[0], b=idx[idx.length-1];
    if(b - a + 1 < 10){
      const need = 10 - (b - a + 1);
      a = Math.max(0, a - Math.ceil(need/2));
      b = Math.min(seq.length-1, b + Math.floor(need/2));
    }
    return seq.slice(a, b+1);
  }catch(e){ return seq.slice(); }
}
// swap left/right hands in a feature vector [pose(12), L(42), R(42)]
function swapHands(vec){
  const pose = vec.slice(0,12);
  const L = vec.slice(12,54);
  const R = vec.slice(54,96);
  return pose.concat(R, L);
}function classify(seq){
  const ds = loadDS();
  if (!ds.length) return { label: '(ë°ì´í„°ì…‹ ì—†ìŒ)', score: 0, topK: [] };

  // ì…ë ¥ ì‹œí€€ìŠ¤(ë³´í†µ 30í”„ë ˆì„)ì—ì„œ í™œë™ êµ¬ê°„ë§Œ ì¶”ì¶œ
  const q0 = Array.isArray(seq) ? seq.slice() : [];
  const q = cropActive(q0);

  // ë ˆì´ë¸”ë³„ ìµœì†Œ DTW ê±°ë¦¬ ìˆ˜ì§‘ (ë¯¸ëŸ¬ ë¶ˆë³€ + ì†=0 ë¹„ìœ¨ í•„í„°)
  const isNullHands = (vec) => {
    const L = sumAbsRange(vec, 12, 54);
    const R = sumAbsRange(vec, 54, 96);
    return (L + R) < 1e-3;
  };

  const per = new Map();
  for (const it of ds) {
    let cand = it.data || [];
    if (!cand.length) continue;

    // candëŠ” ì´ë¯¸ 30í”„ë ˆì„ ë‹¤ìš´ìƒ˜í”Œ ë˜ì–´ ìˆìŒ â†’ í™œë™êµ¬ê°„ë§Œ í¬ë¡­
    const c = cropActive(cand);

    // ì†=0 í”„ë ˆì„ ë¹„ìœ¨ì´ ë†’ìœ¼ë©´ 'ì œì™¸' ëŒ€ì‹  ì¬ì¸¡ì •(fallback) ì ìš©
    const nullRatio = c.length ? c.filter(isNullHands).length / c.length : 1;
    let cUse = c;
    if (nullRatio > 0.6) {
      const c2 = c.filter(f => !isNullHands(f));
      // ë„ˆë¬´ ì§§ì§€ ì•Šìœ¼ë©´(ìµœì†Œ 10í”„ë ˆì„ ë˜ëŠ” ì›ë˜ì˜ 40%) c2ë¡œ ëŒ€ì²´, ì•„ë‹ˆë©´ í¬ì¦ˆ ê¸°ë°˜ìœ¼ë¡œ ì›ë³¸ ìœ ì§€
      if (c2.length >= Math.min(10, Math.floor(c.length * 0.4))) cUse = c2;
    }
// ë¯¸ëŸ¬ ë¶ˆë³€ ê±°ë¦¬ (ì›ë³¸ vs ì†-ìŠ¤ì™‘ ì¤‘ ë” ì‘ì€ ê°’)
    const d = Math.min(
      dtw(q, cUse),
      dtw(q, cUse.map(swapHands))
    );

    const prev = per.get(it.label);
    if (!prev || d < prev.dist) per.set(it.label, { dist: d });
  }

  const pairs = Array.from(per.entries()).map(([label, { dist }]) => ({ label, dist }));
  if (!pairs.length) return { label: '(ìœ íš¨ ìƒ˜í”Œ ì—†ìŒ)', score: 0, topK: [] };

  // --- v5 ìŠ¤íƒ€ì¼ ì ìˆ˜í™” â€” per-query alpha + í™•ë¥  ì •ê·œí™” ---
  function _median(arr){ if(!arr.length) return 1.0; const s=[...arr].sort((a,b)=>a-b); return s[Math.floor(s.length/2)]||1.0; }
  const _dists = pairs.map(p=>p.dist).filter(d=>Number.isFinite(d)&&d>=0);
  let _scale = _median(_dists);
  if(!isFinite(_scale) || _scale <= 1e-6) _scale = 1.0;
  let alpha = 1/Math.max(1e-3, _scale);        // ì•ˆì „ í•˜í•œ
  alpha = Math.min(Math.max(alpha, 0.02), 0.8); // 0.02~0.8ë¡œ í´ë¨í”„(ë¶•ê´´ ë°©ì§€)

  const exps = pairs.map(p => Math.exp(-alpha * p.dist));
  const Z = exps.reduce((a,b)=>a+b, 0) || 1;
  const scored = pairs
    .map((p,i) => ({ label: p.label, score: exps[i] / Z }))
    .sort((a,b)=> b.score - a.score);

  const best = scored[0] || { label:'â€”', score:0 };
  const second = scored[1] || { label:'â€”', score:0 };
  const margin = best.score - second.score;

  // ë¶ˆí™•ì‹¤ ê±°ë¶€(í‘œì‹œëŠ” í•˜ì§€ ì•Šê³  ë‚´ë¶€ì ìœ¼ë¡œë§Œ í”Œë˜ê·¸)
const TH = 0.55, MARGIN = 0.10;
const __uncertain = !(best.score >= TH && margin >= MARGIN);
// ìš”ì²­ì‚¬í•­: ë¯¸í™•ì‹¤ ëŒ€ì‹  1ë“± ë¼ë²¨ì„ ê·¸ëŒ€ë¡œ ì‚¬ìš©
return { label: best.label, score: best.score, topK: scored.slice(0,3), uncertain: __uncertain };}

function renderPred(r){
  const label = r?.label || 'â€”';
  const pct   = Math.round((r?.score || 0) * 100);

  // ë¼ë²¨
  const labEl = $('#predLabel');
  if (labEl) labEl.textContent = label;

  // ì ìˆ˜ ê²Œì´ì§€/í…ìŠ¤íŠ¸ ë™ì‹œ ì—…ë°ì´íŠ¸ (ë¬´ì—‡ì´ë“  ëŒ€ì‘)
  const sEl = $('#predScore');
  if (sEl) {
    // 1) ê²Œì´ì§€/ìŠ¬ë¼ì´ë”/ë¯¸í„°ì¸ ê²½ìš°
    if ('value' in sEl) sEl.value = pct;        // <progress>, <input type="range">, <meter> ë“±
    // 2) ì ‘ê·¼ì„±/ìŠ¤íƒ€ì¼ í›…
    sEl.setAttribute('aria-valuenow', String(pct));
    sEl.dataset.value = String(pct);
    // CSS ë³€ìˆ˜ë¡œ ë„ˆë¹„ë¥¼ ê·¸ë¦¬ëŠ” ê²½ìš°ë¥¼ ëŒ€ë¹„
    sEl.style?.setProperty?.('--score', pct);

    // 3) í…ìŠ¤íŠ¸ ë…¸ë“œì¸ ê²½ìš°(ìŠ¤íŒ¬/ë””ë¸Œ)ë„ ë™ì‘
    //    (ê²Œì´ì§€ê°€ ì•„ë‹Œ ë‹¨ìˆœ ìˆ«ì ìš”ì†Œë¼ë©´ ì´ í•œ ì¤„ë§Œìœ¼ë¡œë„ í‘œì‹œë¨)
    sEl.textContent = String(pct);
  }

  // Top-K ë¦¬ìŠ¤íŠ¸
  const ul = $('#topk');
  if (ul) {
    ul.innerHTML = '';
    (r.topK || []).forEach((x, i) => {
      const li = document.createElement('li');
      li.textContent = `${i+1}. ${x.label} â€” ${(x.score*100).toFixed(1)}`;
      ul.appendChild(li);
    });
  }

  // ë””ë²„ê·¸: ì‹¤ì œ í™•ë¥ ì´ ì–¼ë§ˆì¸ì§€ ì½˜ì†”ë¡œ í™•ì¸ (ì›í•˜ë©´ ì£¼ì„ ì²˜ë¦¬)
  // console.log('pred', { label, pct, r });
}


  // ===== Canvas overlay drawing =====
  function syncCanvasToContainer(c){ const dpr=Math.max(1,window.devicePixelRatio||1); const r=c.getBoundingClientRect(); const w=Math.max(1,Math.floor(r.width*dpr)), h=Math.max(1,Math.floor(r.height*dpr)); if(c.width!==w||c.height!==h){ c.width=w; c.height=h; } }
  function drawOverlay(ctx,r,videoEl,canvasEl){ if(!ctx){return;} ctx.clearRect(0,0,ctx.canvas.width,ctx.canvas.height); if(!r){return;} const vw=Math.max(1,(videoEl?.videoWidth||1)), vh=Math.max(1,(videoEl?.videoHeight||1)); const cw=canvasEl?.width||ctx.canvas.width, ch=canvasEl?.height||ctx.canvas.height; const s=Math.min(cw/vw,ch/vh); const dw=vw*s, dh=vh*s; const ox=(cw-dw)/2, oy=(ch-dh)/2; const map=(p)=>({x:ox+(p.x||0)*dw, y:oy+(p.y||0)*dh}); const HAND=[[0,1],[1,2],[2,3],[3,4],[0,5],[5,6],[6,7],[7,8],[0,9],[9,10],[10,11],[11,12],[0,13],[13,14],[14,15],[15,16],[0,17],[17,18],[18,19],[19,20]]; const ARM=[[11,12],[11,13],[13,15],[12,14],[14,16]]; const lines=(lm,edges,color='#22c55e',lw=3)=>{ if(!lm||!lm.length)return; ctx.save(); ctx.lineJoin='round'; ctx.lineCap='round'; ctx.beginPath(); ctx.strokeStyle='rgba(255,255,255,0.9)'; ctx.lineWidth=lw+2; edges.forEach(([a,b])=>{ const pa=lm[a],pb=lm[b]; if(!pa||!pb) return; const A=map(pa),B=map(pb); ctx.moveTo(A.x,A.y); ctx.lineTo(B.x,B.y); }); ctx.stroke(); ctx.beginPath(); ctx.strokeStyle=color; ctx.lineWidth=lw; edges.forEach(([a,b])=>{ const pa=lm[a],pb=lm[b]; if(!pa||!pb) return; const A=map(pa),B=map(pb); ctx.moveTo(A.x,A.y); ctx.lineTo(B.x,B.y); }); ctx.stroke(); ctx.restore(); }; const dots=(lm,color='#16a34a',rad=3)=>{ if(!lm||!lm.length)return; ctx.save(); for(const p of lm){ const P=map(p); ctx.beginPath(); ctx.fillStyle='rgba(255,255,255,0.9)'; ctx.arc(P.x,P.y,rad+1,0,Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.fillStyle=color; ctx.arc(P.x,P.y,rad,0,Math.PI*2); ctx.fill(); } ctx.restore(); }; try{ if(r.poseLandmarks){ lines(r.poseLandmarks, (window.drawingUtils?.POSE_CONNECTIONS)||ARM, '#22c55e', 3); dots(r.poseLandmarks,'#16a34a',3); } if(r.leftHandLandmarks){ lines(r.leftHandLandmarks, (window.drawingUtils?.HAND_CONNECTIONS)||HAND, '#0ea5e9', 3); dots(r.leftHandLandmarks,'#0284c7',3); } if(r.rightHandLandmarks){ lines(r.rightHandLandmarks, (window.drawingUtils?.HAND_CONNECTIONS)||HAND, '#ef4444', 3); dots(r.rightHandLandmarks,'#dc2626',3); } }catch{}
  }

  // ===== Live capture =====
  const liveVideo=$('#liveVideo'), liveCanvas=$('#liveCanvas'), liveCtx=liveCanvas.getContext('2d');
  let holLive=null, cameraLive=null, capturing=false, captureBuf=[];
  function holisticClass(){ if(typeof window.Holistic==='function') return window.Holistic; if(window.Holistic&&typeof window.Holistic.Holistic==='function') return window.Holistic.Holistic; return null; }
  async function ensureHolLive(){ const Hol=holisticClass(); if(!Hol) throw new Error('ë¡œì»¬ MediaPipe(holistic.js) ê²½ë¡œ í™•ì¸: '+LOCATE_HOLISTIC('holistic.js')); if(holLive) return holLive; holLive=new Hol({ locateFile:LOCATE_HOLISTIC }); holLive.setOptions({ modelComplexity:2, minDetectionConfidence:0.6, minTrackingConfidence:0.6, selfieMode:true, smoothLandmarks:true }); holLive.onResults((r)=>{ if(!liveVideo.videoWidth) return; syncCanvasToContainer(liveCanvas); // mirror overlay data-mode

// --- ì‹¤ì‹œê°„: selfieMode=true ê¸°ì¤€ìœ¼ë¡œ ë“¤ì–´ì˜¨ 'ì™¼/ì˜¤' ë¼ë²¨ì„ ê´€ë¦¬ì ë°ì´í„°ì™€ ë§ì¶¤ ---
let L = r.leftHandLandmarks || null;
let R = r.rightHandLandmarks || null;
// ì‹¤ì‹œê°„(ì…€í”¼) ì…ë ¥ì€ ë¼ë²¨ì´ ê±°ìš¸ ê¸°ì¤€ì¼ ìˆ˜ ìˆìœ¼ë¯€ë¡œ í•œ ë²ˆë§Œ swap
{ const tmp = L; L = R; R = tmp; }

// ì˜¤ë²„ë ˆì´/íŠ¹ì§• ì¢Œí‘œê³„ ì¼ì¹˜: í† ê¸€ OFFì¼ ë•Œë§Œ ë°ì´í„° ì¢Œìš° ë’¤ì§‘ê¸°
const needFlipData = (liveCanvas?.dataset?.mirror === 'data');
const mapX = needFlipData
  ? (arr)=> Array.isArray(arr) ? arr.map(p => ({...p, x: 1 - (p.x || 0)})) : arr
  : (arr)=> arr;

// êµì •ëœ rë¡œ ì¹˜í™˜ (pose/faceë„ ë™ì¼ ê·œì¹™ ì ìš©)
r = {
  ...r,
  leftHandLandmarks:  mapX(L),
  rightHandLandmarks: mapX(R),
  poseLandmarks:      mapX(r.poseLandmarks),
  faceLandmarks:      mapX(r.faceLandmarks),
};

    const cv=liveCanvas; if(cv?.dataset?.mirror==='data'){ const m=(arr)=>Array.isArray(arr)?arr.map(p=>({...p, x:1-(p.x||0)})):arr; r={...r, poseLandmarks:m(r.poseLandmarks), leftHandLandmarks:m(r.leftHandLandmarks), rightHandLandmarks:m(r.rightHandLandmarks), faceLandmarks:m(r.faceLandmarks)}; }
    drawOverlay(liveCtx,r,liveVideo,liveCanvas); if(capturing){ captureBuf.push(feat(r)); }
  }); return holLive; }
  async function startCamera(){ const hol=await ensureHolLive(); cameraLive=new Camera(liveVideo,{ width:960, height:540, onFrame: async()=>{ await hol.send({ image: liveVideo }); } }); await cameraLive.start(); showAlert('ì¹´ë©”ë¼ ì‹œì‘','ok'); }

  // ===== Admin: logging helper =====
  const adminVideo=$('#adminVideo'), adminPreview=$('#adminPreview'), adminCanvas=$('#adminCanvas'), adminCtx=adminCanvas.getContext('2d');
  const adminLog=$('#adminLog'), chkVerbose=$('#chkVerbose'), chkOverlay=$('#chkOverlay');
  const log=(t)=>{ const line=`[${new Date().toLocaleTimeString()}] ${t}`; adminLog.textContent += (adminLog.textContent?"\n":"")+line; adminLog.scrollTop=adminLog.scrollHeight; console.log(line); };
  const deriveLabel=(name)=> name.replace(/\.[^.]+$/,'').trim();
  async function ensureHolAdmin(){ const Hol=holisticClass(); if(!Hol) throw new Error('ë¡œì»¬ MediaPipe(holistic.js)ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ê²½ë¡œ í™•ì¸: '+LOCATE_HOLISTIC('holistic.js')); const hol=new Hol({ locateFile:LOCATE_HOLISTIC }); hol.setOptions({ modelComplexity:1, minDetectionConfidence:0.5, minTrackingConfidence:0.6, selfieMode:false, smoothLandmarks:true, refineFaceLandmarks:false }); return hol; }
  async function ensureVideoAutoPlay(v){ try{ v.autoplay=true; v.muted=true; v.playsInline=true; v.preload='auto'; await v.play(); }catch(e){ const once=()=>{ v.play().catch(()=>{}); document.removeEventListener('click',once); }; document.addEventListener('click',once,{once:true}); showAlert('ë¸Œë¼ìš°ì €ê°€ ìë™ì¬ìƒì„ ì œí•œí–ˆìŠµë‹ˆë‹¤. í™”ë©´ì„ í•œ ë²ˆ í´ë¦­í•˜ë©´ ì¬ìƒë©ë‹ˆë‹¤.','warn'); } }

  // ===== IndexedDB (dictionary videos) =====
  function idbOpen(){ return new Promise((resolve,reject)=>{ const r=indexedDB.open(DICT_DB,1); r.onupgradeneeded=(e)=>{ const db=e.target.result; if(!db.objectStoreNames.contains(DICT_STORE)){ db.createObjectStore(DICT_STORE,{keyPath:'key'}); } }; r.onsuccess=()=>resolve(r.result); r.onerror=()=>reject(r.error); }); }
  async function dictPut(label, file){ const db=await idbOpen(); return new Promise((resolve,reject)=>{ const tx=db.transaction(DICT_STORE,'readwrite'); tx.oncomplete=()=>resolve(true); tx.onerror=()=>reject(tx.error); const store=tx.objectStore(DICT_STORE); store.put({key:label, type:file.type||'video/mp4', blob:file}); }); }
  async function dictGet(label){ const db=await idbOpen(); return new Promise((resolve,reject)=>{ const tx=db.transaction(DICT_STORE,'readonly'); const store=tx.objectStore(DICT_STORE); const req=store.get(label); req.onsuccess=()=>resolve(req.result||null); req.onerror=()=>reject(req.error); }); }
  async function dictKeys(){ const db=await idbOpen(); return new Promise((resolve,reject)=>{ const tx=db.transaction(DICT_STORE,'readonly'); const store=tx.objectStore(DICT_STORE); if(store.getAllKeys){ const req=store.getAllKeys(); req.onsuccess=()=>resolve(req.result||[]); req.onerror=()=>reject(req.error); } else { const out=[]; const cur=store.openCursor(); cur.onsuccess=(e)=>{ const c=e.target.result; if(c){ out.push(c.key); c.continue(); } else resolve(out); }; cur.onerror=()=>reject(cur.error); } }); }

  // ===== Dictionary UI =====
  async function renderDictList(filter=''){ const ul=$('#dictList'); if(!ul) return; const keys=(await dictKeys()).map(String).sort(); const q=(filter||'').toLowerCase(); const list=keys.filter(k=>k.toLowerCase().includes(q)); ul.innerHTML = list.length ? list.map(k=>`<li class="row"><span>${k}</span><button class="btn btn--ghost" style="border:1px solid var(--border);padding:4px 8px;font-size:12px" data-action="play-dict" data-label="${k}">ì¬ìƒ</button></li>`).join('') : '<li class="muted">ì‚¬ì „ í•­ëª©ì´ ì—†ìŠµë‹ˆë‹¤.</li>'; }
  async function playDict(label){ const item=await dictGet(label); if(!item){ showAlert('ì‚¬ì „ ì˜ìƒì´ ì—†ìŠµë‹ˆë‹¤. ê´€ë¦¬ìì—ì„œ ì—…ë¡œë“œí•˜ì„¸ìš”.','warn'); return; } const url=URL.createObjectURL(item.blob); const v=$('#dictVideo'); try{ v.src=url; await v.play().catch(()=>{}); } finally { v.onended=()=>{ try{ URL.revokeObjectURL(url);}catch{} }; } }

  // ===== Admin: main processing =====
  let __processingVideos=false;
  async function processUploadedVideos(){ if(__processingVideos){ log('[ì¤‘ë³µë°©ì§€] ì´ë¯¸ ì²˜ë¦¬ ì¤‘ì…ë‹ˆë‹¤.'); return; } __processingVideos=true; try{ const files=Array.from(adminVideo.files||[]); if(!files.length){ showAlert('ì˜ìƒì„ ì„ íƒí•˜ì„¸ìš”','warn'); log('ì…ë ¥ íŒŒì¼ 0ê°œ â€” ì¤‘ë‹¨'); return; } log(`ì²˜ë¦¬ ì‹œì‘: ì„ íƒëœ íŒŒì¼ ${files.length}ê°œ`); let hol; try{ log('Holistic ì¸ìŠ¤í„´ìŠ¤ ìƒì„± ì‹œë„'); hol=await ensureHolAdmin(); log('Holistic ì¤€ë¹„ ì™„ë£Œ'); }catch(e){ showAlert(e.message,'err'); log('Holistic ì¤€ë¹„ ì‹¤íŒ¨: '+(e?.message||e)); return; } adminLog.textContent=''; if(chkOverlay) chkOverlay.checked=true; let i=0; for(const f of files){ i++; let label=deriveLabel(f.name);
// macOS Unicode normalization & zero-width cleanup
const _N=(s)=> (s&&s.normalize)? s.normalize('NFC') : (s||'');
const _Z=(s)=> _N(String(s)).replace(/[\u200B\u200C\u200D\uFEFF]/g,'').trim();
const rawName=_Z(f.name);
label=_Z(label); log(`[${i}/${files.length}] â–¶ ${rawName} â†’ label="${label}"`);
          // â”€â”€ ì‚¬ì „ìš© ì²˜ë¦¬: DBì— ì›ë³¸ ì˜ìƒ ì €ì¥ + ì¶”ì¶œì€ ì ‘ë¯¸ì‚¬ ì œê±°í•œ ë ˆì´ë¸”ë¡œ ê³„ì† â”€â”€
          try{
            const mDict = label && label.match(/(.+?)_ì‚¬ì „ìš©(?:\s*\(\d+\))?$/u);
            if(mDict){
              const base = (mDict[1]||'').trim();
              try{ await dictPut(base, f); log(`ì‚¬ì „ìš© ì €ì¥ ì™„ë£Œ: "${base}"`); }catch(e){ log(`[ì‚¬ì „ìš© ì €ì¥ ì‹¤íŒ¨] ${e&&e.message?e.message:e}`); }
              label = base; // ì ‘ë¯¸ì‚¬ ì œê±° í›„ ì¶”ì¶œ ì§„í–‰
            }
          }catch(e){ log(`[ì‚¬ì „ìš© ì²˜ë¦¬ ì˜¤ë¥˜] ${e&&e.message?e.message:e}`); }
          hol.__firstPass = (i===1);  // mark first sample for forced accept
          const item=await processOne(f,label,hol);
          hol.__firstPass = false; if(item){ log(`ì €ì¥ì™„ë£Œ: ${label} frames=${item.frames}, dim=${item.dim}`);} else { log(`ìŠ¤í‚µ: ${label} â€” ìœ íš¨ í”„ë ˆì„ ì—†ìŒ`);} } showAlert(`${files.length}ê°œ ì²˜ë¦¬ ì™„ë£Œ`,'ok'); } finally { __processingVideos=false; } }

  // ===== Robust processOne (r7.2 consolidated) =====
  if(!window.__processOneVersion || window.__processOneVersion < 72){ window.__processOneVersion = 72; }
  function seekTo(video, t){ return new Promise(res=>{ const on=()=>{ video.removeEventListener('seeked',on); res(); }; video.addEventListener('seeked',on,{once:true}); try{ video.currentTime=t; }catch{ video.removeEventListener('seeked',on); res(); } }); }
  const STRICT = {
      minValidFrames: 40,
      minCoverage: 0.55,
      maxOnset: 0.30,
      minSpan: 0.50,
      minHandsRatio: 0.30
    }

function strictCheck(stats, times, validFlags, handAny, dur){
      const total = stats.f||0;
      const validIdx = validFlags.map((v,i)=> v? i : -1).filter(i=> i>=0);
      const valid = validIdx.length;
      const coverage = total? valid/total : 0;
      const hands = handAny.filter(Boolean).length;
      const handsRatio = total? hands/total : 0;
      let firstT = NaN, lastT = NaN, spanRatio = 0, onsetRatio = 1;
      if(valid){ firstT = times[validIdx[0]]||0; lastT = times[validIdx[validIdx.length-1]]||firstT; }
      if(dur>0 && valid){ spanRatio = (lastT-firstT)/dur; onsetRatio = firstT/dur; }

      const reasons=[];
      if(valid < STRICT.minValidFrames) reasons.push(`ìœ íš¨í”„ë ˆì„ ë¶€ì¡±(${valid}/${STRICT.minValidFrames})`);
      if(coverage < STRICT.minCoverage) reasons.push(`ì»¤ë²„ë¦¬ì§€ ë¶€ì¡±(${Math.round(coverage*100)}%<${Math.round(STRICT.minCoverage*100)}%)`);
      if(handsRatio < STRICT.minHandsRatio) reasons.push(`ì† ê²€ì¶œ ë¶€ì¡±(${Math.round(handsRatio*100)}%<${Math.round(STRICT.minHandsRatio*100)}%)`);
      if(dur>0){
        if(onsetRatio > STRICT.maxOnset) reasons.push(`ì´ˆê¸°êµ¬ê°„ ê°ì§€ ë¶€ì¡±(ì‹œì‘ ${Math.round(onsetRatio*100)}%>${Math.round(STRICT.maxOnset*100)}%)`);
        if(spanRatio < STRICT.minSpan) reasons.push(`ê°ì§€ êµ¬ê°„ ì§§ìŒ(${Math.round(spanRatio*100)}%<${Math.round(STRICT.minSpan*100)}%)`);
      }
      return { pass: reasons.length===0, reasons, summary:{total,valid,coverage,handsRatio,firstT,lastT,spanRatio,onsetRatio} };
    }

  async function rescueScan(hol, video, feats, stats, times, validFlags, handAny, opts={}){
      const dur = isFinite(video.duration)?video.duration:0; if(!dur) return false;
      const {mode='uniform', range=[0,1], N=null, reset=false} = opts;
      log(`ã€êµ¬ì œã€‘ ì‹œí¬ ê¸°ë°˜ ê°•ì œ ìŠ¤ìº” ì‹œì‘ (mode=${mode}, range=${(range[0]*100|0)}~${(range[1]*100|0)}%)`);
      try{ video.pause(); }catch{}
      // í•„ìš” ì‹œ ì™„ì „ ì¬ì¶”ì¶œ: ê¸°ì¡´ ëˆ„ì  ë²„í¼ ì´ˆê¸°í™”
      if(reset){ feats.length=0; times.length=0; validFlags.length=0; handAny.length=0; stats.f=stats.p=stats.l=stats.r=stats.d=0; }
      const w=video.videoWidth, h=video.videoHeight; const off=document.createElement('canvas'); off.width=w; off.height=h; const ox=off.getContext('2d',{willReadFrequently:true});
      const [rs,re] = [Math.max(0,range[0]), Math.min(1,range[1])];
      const start = rs*dur, end = Math.max(start, re*dur);
      const targetN = N ?? Math.min(150, Math.max(60, Math.round((end-start)*30))); // 30fps ê°€ì •
      const dt = (targetN>1)? (end-start)/(targetN-1) : (end-start);
      for(let i=0;i<targetN;i++){
        const t = Math.min(end, start + i*dt);
        await new Promise(res=>{ const on=()=>{ video.removeEventListener('seeked',on); res(); }; video.addEventListener('seeked',on,{once:true}); try{ video.currentTime=t; }catch{ video.removeEventListener('seeked',on); res(); } });
        ox.drawImage(video, 0, 0, w, h);
        try{ await hol.send({image:off}); }catch{ stats.d++; }
        if(i%15===0) log(`ã€êµ¬ì œã€‘ ì§„í–‰ ${Math.round((i+1)*100/targetN)}% (t=${t.toFixed(2)}s)`);
        await new Promise(r=>requestAnimationFrame(r));
      }
      log('ã€êµ¬ì œã€‘ ì™„ë£Œ');
      return true;
    }
  // === Warmup to stabilize Mediapipe Holistic on first frames ===
async function warmupHolistic(hol, video, frames=18){
  const w = video.videoWidth || 0, h = video.videoHeight || 0;
  if(!w || !h) return;
  const off = document.createElement('canvas'); off.width=w; off.height=h;
  const ctx = off.getContext('2d', { willReadFrequently:true });
  try { if (isFinite(video.duration)) { video.currentTime = Math.min(0.05, video.duration * 0.02); } } catch(e){}
  for(let i=0;i<frames;i++){
    ctx.drawImage(video, 0, 0, w, h);
    try { await hol.send({ image: off }); } catch(e){}
    await new Promise(r=>requestAnimationFrame(r));
  }
}
function processOne(file,label,hol){
  return new Promise(async (resolve)=>{
    // --- state & buffers ---
    let stopped=false, sameCT=0, lastCT=-1, busy=false, sendTimeout=null;
    let rafLogId=0, rafPumpId=0, ivPumpId=0;

    const feats=[];                           // feature vectors
    const stats={f:0,p:0,l:0,r:0,d:0};        // counters
    const times=[];                            // frame times (sec)
    const validFlags=[];                       // any landmark present
    const handAny=[];                          // any hand present

    const clearTimers=()=>{
      try{ cancelAnimationFrame(rafLogId); }catch{}
      try{ cancelAnimationFrame(rafPumpId);}catch{}
      try{ clearInterval(ivPumpId);}catch{}
    };

    const finOnce = async () => {
      if (stopped) return;
      stopped = true;
      clearTimers();

      try { adminPreview.pause(); } catch {}
      try { if (adminPreview.src?.startsWith('blob:')) URL.revokeObjectURL(adminPreview.src); } catch {}

      // quality check using collected per-frame arrays
      const dur = isFinite(adminPreview.duration) ? adminPreview.duration : 0;
      const chk = strictCheck(stats, times, validFlags, handAny, dur); if (!chk.pass) { if (hol && hol.__firstPass) { log('[ì²« ì˜ìƒ ì˜ˆì™¸] í’ˆì§ˆ ê¸°ì¤€ ë¯¸ë‹¬ â†’ í‚¤í”„ë ˆì„ êµ¬ì œ ìŠ¤ìº” ì‹¤í–‰'); try { await rescueIfLowFrames(true); } catch(e){} await new Promise(r=>requestAnimationFrame(()=>requestAnimationFrame(r))); } else { log(`[í•„í„°: ìŠ¤í‚µ] ${chk.reasons.join(' / ')}`); try { resolve(null); } catch {} return; } }

      const seq = downsample(feats, 30);
      if (!seq.length) { try{ resolve(null); }catch{} return; }

      const item = {
        id: crypto.randomUUID(),
        label,
        frames: seq.length,
        dim: seq[0]?.length || 96,
        data: seq,
        added: Date.now(),
      };

      try {
        const ds = loadDS();
        ds.push(item);
        saveDS(ds);
      } catch (e) {
        log('[fin] saveDS ì—ëŸ¬: ' + (e?.message || e));
      }

      const pr=(k)=> stats.f ? Math.round(stats[k]*100/stats.f) : 0;
      log(`ê²€ì¶œí†µê³„: frames=${stats.f}, pose=${pr('p')}%, L=${pr('l')}%, R=${pr('r')}%, drop=${stats.d}`);

      try { resolve(item); } catch {}
    };

    // Low-frame rescue with guarded seek and timeout
    const rescueIfLowFrames = async (force=false) => {
      const dur = isFinite(adminPreview.duration) ? adminPreview.duration : 0;
      if (!force && (stats.f >= 20 || !dur)) return false;

      log('ì €í”„ë ˆì„ ê°ì§€ â€” í”„ë ˆì„ ìŠ¤í… ì¬ìˆ˜ì§‘ ì‹œì‘');
      try { adminPreview.pause(); } catch {}
      busy = false;

      const N = 30;
      for (let i = 0; i < N; i++) {
        const t = Math.min(dur - 0.001, (i + 0.5) * dur / N);

        // seek with 300ms timeout
        await new Promise(r=>{
          let done=false;
          const onSeek = () => {
            if (done) return;
            done = true;
            adminPreview.removeEventListener('seeked', onSeek);
            r();
          };
          adminPreview.addEventListener('seeked', onSeek, { once:true });
          try { adminPreview.currentTime = t; } catch { onSeek(); }
          setTimeout(()=>{ if(!done){ log('[êµ¬ì œ] seeked íƒ€ì„ì•„ì›ƒ â†’ ê³„ì† ì§„í–‰'); onSeek(); } }, 300);
        });

        try { await hol.send({ image: adminPreview }); } catch { stats.d++; }
        await new Promise(r=>requestAnimationFrame(r));
      }

      log(`ì¬ìˆ˜ì§‘ ì™„ë£Œ: framesâ‰ˆ${stats.f}`);

      // Deadman switch: ensure finishing even if no more events arrive
      setTimeout(()=>{ try{ if(!stopped) finOnce(); }catch(e){ log('[êµ¬ì œ fin] '+(e?.message||e)); } }, 2000);

      return true;
    };

    try{
      // Source prep
      adminPreview.loop=false; adminPreview.src=''; adminPreview.currentTime=0;
      adminPreview.src = URL.createObjectURL(file);

      await new Promise(r=>{ if(adminPreview.readyState>=2) r(); else adminPreview.addEventListener('loadeddata', r, {once:true}); });
      await new Promise(r=>{ if(adminPreview.readyState>=3) r(); else adminPreview.addEventListener('canplay', r, {once:true}); });

      if((adminPreview.currentTime||0)===0){ try{ adminPreview.currentTime=0.001; }catch{} }
      adminPreview.playbackRate=1.0; adminPreview.muted=true; adminPreview.playsInline=true; adminPreview.preload='auto';
      try { await adminPreview.play(); } catch {}

      await new Promise(r=>{ if(!adminPreview.paused) r(); else adminPreview.addEventListener('playing', r, {once:true}); });

      adminCanvas.width = adminPreview.videoWidth;
      adminCanvas.height = adminPreview.videoHeight;

      // Always finalize on end
      adminPreview.addEventListener('ended', onEnded, { once:true });
      async function onEnded(){
        try {
          log('ë¹„ë””ì˜¤ ended ì´ë²¤íŠ¸ ê°ì§€');
          clearTimers();

          if (stats.f < 20) {
            await rescueIfLowFrames();
          }

          // flush pending results
          await new Promise(r => requestAnimationFrame(() => requestAnimationFrame(r)));
        } catch (e) {
          log('[ended í•¸ë“¤ëŸ¬ ì˜¤ë¥˜] ' + (e?.message || e));
        } finally {
          finOnce();
        }
      }

      // timeupdate backup pump
      adminPreview.addEventListener('timeupdate', ()=>{ if(!stopped) pump(); });

      // On results: collect features and quality arrays
      hol.onResults((r)=>{
        try {
          syncCanvasToContainer(adminCanvas);
          if(!chkOverlay || chkOverlay.checked) drawOverlay(adminCtx, r, adminPreview, adminCanvas);
        }catch{}

        feats.push(feat(r));
        stats.f++;
        if (r.poseLandmarks) stats.p++;
        if (r.leftHandLandmarks) stats.l++;
        if (r.rightHandLandmarks) stats.r++;

        const t = adminPreview.currentTime || 0;
        times.push(t);
        const hasPose = !!r.poseLandmarks;
        const hasL = !!r.leftHandLandmarks;
        const hasR = !!r.rightHandLandmarks;
        validFlags.push(hasPose || hasL || hasR);
        handAny.push(hasL || hasR);
      });

      const pump = () => {
        if (stopped || busy) return;
        busy = true;
        let settled = false;
        const clear = () => {
          busy = false;
          if (sendTimeout){ clearTimeout(sendTimeout); sendTimeout=null; }
        };
        hol.send({ image: adminPreview })
           .then(()=>{ settled = true; })
           .catch(()=>{ stats.d++; })
           .finally(clear);
        sendTimeout = setTimeout(()=>{ if(!settled){ stats.d++; clear(); } }, 500);
      };

      const dur = isFinite(adminPreview.duration) ? adminPreview.duration : 0;
      const endLikely = () => (adminPreview.currentTime >= dur - 0.033) || (dur && (dur - adminPreview.currentTime) < 0.05);

      if ('requestVideoFrameCallback' in HTMLVideoElement.prototype) {
        const step = () => {
          if (stopped) return;
          const ct = adminPreview.currentTime || 0;
          sameCT = (ct === lastCT) ? sameCT + 1 : 0;
          lastCT = ct;
          pump();
          if (endLikely() && sameCT > 12) {
            log('ë§ˆì§€ë§‰ í”„ë ˆì„ ì•ˆì •í™” ê°ì§€');
            clearTimers();
            if (stats.f < 20) { rescueIfLowFrames().then(finOnce); }
            else { finOnce(); }
            return;
          }
          adminPreview.requestVideoFrameCallback(step);
        };
        adminPreview.requestVideoFrameCallback(step);
      }

      const rafPump = () => { if (stopped) return; pump(); rafPumpId = requestAnimationFrame(rafPump); };
      rafPumpId = requestAnimationFrame(rafPump);
      ivPumpId = setInterval(pump, 33);

      const rafLog = (ts) => {
        if (stopped) return;
        const verbose = !!(chkVerbose?.checked);
        const every = verbose ? 400 : 1200;
        if ((ts % every) < 16) {
          const t = adminPreview.currentTime || 0;
          const pct = dur ? Math.min(100,(t/dur)*100).toFixed(1) : 'â€”';
          const pr=(k)=> stats.f? Math.round(stats[k]*100/stats.f):0;
          log(`ì§„í–‰ ${pct}% t=${t.toFixed(2)}s/${dur?dur.toFixed(2)+'s':'?'} frames=${stats.f} det pose ${pr('p')}% L ${pr('l')}% R ${pr('r')}% drop=${stats.d}`);
        }
        rafLogId = requestAnimationFrame(rafLog);
      };
      rafLogId = requestAnimationFrame(rafLog);

      // Early nudge
      setTimeout(()=>{
        try{
          if(!stopped && stats.f < 6){
            const t = Math.min((adminPreview.currentTime||0)+0.033, Math.max(0,(dur-0.1)));
            adminPreview.currentTime = t;
            log('í”„ë ˆì„ ì €ì§„í–‰ ê°ì§€ â†’ ì‹œí¬ ë„ˆì§€');
          }
        }catch{}
      }, 900);

    } catch (err) {
      log('ì—ëŸ¬: ' + (err?.message || err));
      try{ resolve(null); }catch{}
    }
  });
}

  // ===== Mirror toggle (overlay only) =====
  const LS_MIRROR='ksl.mirror.overlay';
  function applyOverlayMirror(on){ const cv=$('#liveCanvas'); const v=$('#liveVideo'); try{ if(cv){ cv.dataset.mirror = on ? '' : 'data'; } if(v){ v.style.transformOrigin='center center'; v.style.transform = on ? 'scaleX(-1)' : ''; } localStorage.setItem(LS_MIRROR, on?'1':'0'); console.log('[KSL] mirror set ->', on, 'dataset:', (cv&&cv.dataset?cv.dataset.mirror:'')); }catch(e){ console.warn('mirror err', e); } }

  // ===== Debug logger (safe, cleaned) =====
  (function(){
    const MAXF=30; const DBG={buf:[], lastLog:0, alpha:null};
    const flatL2=(A,B)=>{ let s=0,c=0; const n=A.length,m=A[0]?.length||0; for(let i=0;i<n;i++){ const a=A[i], b=B[i]||B[Math.min(i,B.length-1)]; for(let j=0;j<m;j++){ const d=(a[j]||0)-(b[j]||0); s+=d*d; c++; } } return Math.sqrt(s/Math.max(1,c)); };
    function computeAlpha(ds){ const by=new Map(); for(const it of ds){ (by.get(it.label)||by.set(it.label,[]).get(it.label)).push(it); } const sample=[]; for(const [,arr] of by){ for(let i=0;i<Math.min(arr.length,4);i++){ for(let j=i+1;j<Math.min(arr.length,5);j++){ sample.push(flatL2(arr[i].data, arr[j].data)); } } } const med=sample.sort((a,b)=>a-b)[Math.floor(sample.length/2)]||1.0; return 1/Math.max(1e-6,med); }
    function debugOnce(seq){ const ds=loadDS(); if(!ds.length) return; if(DBG.alpha==null) DBG.alpha=computeAlpha(ds); const per=new Map(); for(const it of ds){ const d=flatL2(seq,it.data); const cur=per.get(it.label); if(!cur||d<cur.d) per.set(it.label,{d}); } const ranked=[...per.entries()].map(([label,{d}])=>({label,d})).sort((a,b)=>a.d-b.d); const d1=ranked[0]?.d??1e9; const alpha=DBG.alpha; const scores=ranked.map(({label,d})=>({label,s:Math.exp(-alpha*d)})); const Z=scores.reduce((a,b)=>a+b.s,0)||1; const probs=scores.map(({label,s})=>({label,p:s/Z})); const top=probs[0]; if(top){ try{ window.dispatchEvent(new CustomEvent('ksl:recognized',{detail:{label:top.label, score:top.p, source:'debug'}})); }catch{} }
    }
    const prevDraw=drawOverlay; drawOverlay=function(ctx,result,video,canvas){ try{ if(canvas && canvas.id==='liveCanvas'){ const f=feat(result); if(Array.isArray(f)&&f.length){ DBG.buf.push(f); if(DBG.buf.length>MAXF) DBG.buf.shift(); } const t=performance?.now?.()??Date.now(); if(DBG.buf.length>=MAXF && t-DBG.lastLog>400){ DBG.lastLog=t; const seq=downsample(DBG.buf,MAXF); debugOnce(seq); } } }catch{} return prevDraw.apply(this, arguments); };
  })();

  // ===== Safe API (single source of truth) =====
  function makeSafe(){ return {
    tab(key){ try{ const tabs=$$('.tab-btn'); const panels=$$('.tab-panel'); tabs.forEach(b=>{ const on=b.dataset.tab===key; b.setAttribute('aria-selected', on?'true':'false'); }); panels.forEach(p=>{ const on=p.id==='panel-'+key; p.setAttribute('aria-hidden', on?'false':'true'); }); }catch(e){ console.warn('tab err',e);} },
    async startCam(){ try{ await startCamera(); }catch(e){ showAlert(e.message||e,'err'); } },
    async capture(){ try{ if(!cameraLive){ showAlert('ë¨¼ì € ì¹´ë©”ë¼ë¥¼ ì¼œì„¸ìš”.','warn'); return;} capturing=true; captureBuf=[]; showAlert('3ì´ˆ ìº¡ì²˜ ì‹œì‘â€¦','info'); await new Promise(r=>setTimeout(r,3000)); capturing=false; const seq=downsample(captureBuf,30); if(!seq.length){ showAlert('ëœë“œë§ˆí¬ê°€ ê°ì§€ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.','warn'); return;} const r=classify(seq); renderPred(r); maybeAwardXP(r.label, Math.round(r.score*100)); }catch(e){ showAlert(e.message||e,'err'); } },
    nextTarget(){ try{ const labels=[...new Set(loadDS().map(x=>x.label))]; if(!labels.length) return; const cur=getTarget(); const i=Math.max(0,labels.indexOf(cur)); setTarget(labels[(i+1)%labels.length]); }catch(e){ console.warn('nextTarget err',e);} },
    quiz(){ try{ const unitId=$('#quizUnit').value; runQuiz(unitId); }catch(e){ showAlert(e.message||e,'err'); } },
    processVideos(){ try{ processUploadedVideos(); }catch(e){ showAlert(e.message||e,'err'); } },
    exportDS(){ try{ const blob=new Blob([JSON.stringify(loadDS(),null,2)],{type:'application/json'}); const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='ksl_dataset.json'; a.click(); }catch(e){ showAlert(e.message||e,'err'); } },
    refreshDS(){ try{ refreshDatasetList(); }catch(e){ console.warn('refreshDS err',e);} },
    clearDS(){ try{ if(confirm('ì •ë§ ì „ì²´ ì‚­ì œí• ê¹Œìš”?')){ localStorage.setItem(DS_KEY,'[]'); refreshDatasetList(); buildLessonUnits(); refreshLabelList(); showAlert('ë°ì´í„°ì…‹ ì´ˆê¸°í™” ì™„ë£Œ','ok'); } }catch(e){ showAlert(e.message||e,'err'); } },
    clearLog(){ try{ adminLog.textContent=''; }catch(e){ console.warn('clearLog err',e);} }
  }; }

  
function bindUI(){
  const SEL='[data-action], .tab-btn, #btnStartCam, #btnCapture, #btnNextTarget, #btnStartQuiz, #btnProcessVideo, #btnExport, #btnRefreshDS, #btnClearDS, #btnClearLog, #btnMode, #dictClear, #dictSearch';
  const delegate = (ev) => {
    const t = ev.target.closest(SEL);
    if(!t) return;
    if(ev.type==='keyup' && !(ev.key==='Enter'||ev.key===' ')) return;

    try{
      if(t.id==='btnMode'){ document.documentElement.setAttribute('data-mode', document.documentElement.getAttribute('data-mode')==='vivid'?'default':'vivid'); return; }
      if(t.dataset?.tab){ __callSafe('tab', t.dataset.tab); return; }
      if(t.id==='btnStartCam') return __callSafe('startCam');
      if(t.id==='btnCapture') return __callSafe('capture');
      if(t.id==='btnNextTarget') return __callSafe('nextTarget');
      if(t.id==='btnStartQuiz') return __callSafe('quiz');
      if(t.id==='btnProcessVideo') return __callSafe('processVideos');
      if(t.id==='btnExport') return __callSafe('exportDS');
      if(t.id==='btnRefreshDS') return __callSafe('refreshDS');
      if(t.id==='btnClearDS') return __callSafe('clearDS');
      if(t.id==='btnClearLog') return __callSafe('clearLog');
      if(t.dataset.action==='set-target'){ setTarget(t.dataset.label); showAlert(`ëª©í‘œë¥¼ "${t.dataset.label}"(ìœ¼)ë¡œ ì„¤ì •í–ˆìŠµë‹ˆë‹¤.`,'info'); return; }
      if(t.dataset.action==='quiz-from-unit'){ runQuiz(t.dataset.unit); return; }
      if(t.dataset.action==='play-dict'){ playDict(t.dataset.label); return; }
      if(t.id==='dictClear'){ const input=$('#dictSearch'); if(input){ input.value=''; renderDictList(''); } return; }
    }catch(e){ console.warn('delegate err',e); }
  };
  ['click','keyup'].forEach(evt=>document.addEventListener(evt, delegate, true));

  // Mirror toggle wiring
  try{
    const mirrorChk=$('#mirrorChk');
    const wrap = $('#mirrorToggleWrap');
    const sw = wrap ? wrap.querySelector('.switch') : null;
    const lbl = $('#mirrorLbl');
    const updateAria = (on)=>{ if(sw){ sw.setAttribute('aria-checked', on ? 'true' : 'false'); } };
    const toggleMirror = ()=>{ if(!mirrorChk) return; mirrorChk.checked = !mirrorChk.checked; updateAria(mirrorChk.checked); applyOverlayMirror(mirrorChk.checked); };
    if(sw){
      sw.setAttribute('tabindex','0');
      sw.addEventListener('click', (e)=>{ e.preventDefault(); toggleMirror(); }, true);
      sw.addEventListener('keyup', (e)=>{ if(e.key==='Enter'||e.key===' '){ e.preventDefault(); toggleMirror(); } }, true);
    }
    if(lbl){ lbl.addEventListener('click', (e)=>{ e.preventDefault(); toggleMirror(); }, true); }
    if(mirrorChk) updateAria(mirrorChk.checked);
  }catch(e){ console.warn('mirror wiring err', e); }

  // Direct bindings for critical buttons (fallback if delegation fails)
  try{
    const ids = ['btnProcessVideo','btnStartCam','btnCapture','btnNextTarget','btnStartQuiz','btnExport','btnRefreshDS','btnClearDS','btnClearLog','tabbtn-learn','tabbtn-lessons','tabbtn-admin','btnMode'];
    const map = {
      'btnProcessVideo': ()=> __callSafe('processVideos'),
      'btnStartCam': ()=> __callSafe('startCam'),
      'btnCapture': ()=> __callSafe('capture'),
      'btnNextTarget': ()=> __callSafe('nextTarget'),
      'btnStartQuiz': ()=> __callSafe('quiz'),
      'btnExport': ()=> __callSafe('exportDS'),
      'btnRefreshDS': ()=> __callSafe('refreshDS'),
      'btnClearDS': ()=> __callSafe('clearDS'),
      'btnClearLog': ()=> __callSafe('clearLog'),
      'tabbtn-learn': ()=> __callSafe('tab','learn'),
      'tabbtn-lessons': ()=> __callSafe('tab','lessons'),
      'tabbtn-admin': ()=> __callSafe('tab','admin'),
      'btnMode': ()=> { const m=document.documentElement.getAttribute('data-mode')==='vivid'?'default':'vivid'; document.documentElement.setAttribute('data-mode', m); }
    };
    ids.forEach(id=>{
      const el = document.getElementById(id);
      if(!el) return;
      el.addEventListener('click', (ev)=>{ ev.stopPropagation(); try{ map[id](); }catch(e){ console.warn('direct click err', e); } }, true);
    });
  }catch(e){ console.warn('direct bind err', e); }

  // Global click logger (for debugging)
  try{
    document.addEventListener('click', (e)=>{
      try{
        const t = e.target;
        const info = `[click] id=${t.id||'-'} tag=${t.tagName} class=${(t.className||'').toString().slice(0,80)}`;
        if (typeof log === 'function') log(info); else console.log(info);
      }catch{}
    }, true);
  }catch{}

  // JSON import handler (merge + dedupe)
  try{
    const inp = document.getElementById('importJson');
    if(inp){
      inp.addEventListener('change', async ()=>{
        try{
          const f = inp.files && inp.files[0];
          if(!f){ showAlert('ê°€ì ¸ì˜¬ .json íŒŒì¼ì„ ì„ íƒí•˜ì„¸ìš”','warn'); return; }
          const text = await f.text();
          let raw=null; try{ raw=JSON.parse(text); }catch(e){ showAlert('JSON íŒŒì‹± ì‹¤íŒ¨','err'); log('[ê°€ì ¸ì˜¤ê¸° ì‹¤íŒ¨] '+(e?.message||e)); return; }
          let arr = Array.isArray(raw)? raw : (
            Array.isArray(raw.dataset)? raw.dataset :
            Array.isArray(raw.items)? raw.items :
            Array.isArray(raw.ds)? raw.ds :
            (raw && Array.isArray(raw.data)? raw.data : [])
          );
          if(!arr.length){ showAlert('ìœ íš¨í•œ ë°ì´í„°ì…‹ì´ ì•„ë‹™ë‹ˆë‹¤','err'); return; }
          const now = Date.now(); const norm=[];
          for(const it of arr){
            if(!it) continue;
            const label = String(it.label || it.name || it.word || it.title || '').trim();
            let data = it.data || it.seq || it.sequence || it.samples;
            if(!Array.isArray(data)) continue;
            data = data.filter(fr=>Array.isArray(fr)).map(fr=>fr.map(x=>+x||0));
            if(!data.length) continue;
            const dim = it.dim || (data[0]?.length||0);
            const frames = it.frames || data.length;
            const id = it.id || (crypto?.randomUUID? crypto.randomUUID() : ('imp_'+Math.random().toString(36).slice(2)));
            const added = it.added || now;
            norm.push({ id, label: label || '(ë¬´ëª…)', frames, dim, data, added });
          }
          if(!norm.length){ showAlert('ê°€ì ¸ì˜¬ í•­ëª©ì´ ì—†ìŠµë‹ˆë‹¤','warn'); return; }
          const ex = loadDS();
          const ids = new Set(ex.map(x=>x.id));
          const keys = new Set(ex.map(x=>x.label+'|'+x.frames+'|'+x.dim));
          let addedCnt=0;
          for(const it of norm){
            const key = it.label+'|'+it.frames+'|'+it.dim;
            if(ids.has(it.id) || keys.has(key)) continue;
            ex.push(it); ids.add(it.id); keys.add(key); addedCnt++;
          }
          saveDS(ex);
          showAlert(`ê°€ì ¸ì˜¤ê¸° ì™„ë£Œ: ${addedCnt}ê°œ ì¶”ê°€`,'ok');
          try{ inp.value=''; }catch{}
        }catch(e){ showAlert('ê°€ì ¸ì˜¤ê¸° ì¤‘ ì˜¤ë¥˜','err'); log('[ê°€ì ¸ì˜¤ê¸° ì˜¤ë¥˜] '+(e?.message||e)); }
      });
    }
  }catch(e){ console.warn('import bind err', e); }

}


  // ===== Bootstrap =====
  window.addEventListener('DOMContentLoaded', async ()=>{
    window.__safe = makeSafe();
    (window.__pending_calls||[]).splice(0).forEach(([name,args])=>{ try{ const fn=window.__safe[name]; typeof fn==='function' && fn.apply(null,args); }catch(e){} });
    bindUI(); refreshDatasetList(); buildLessonUnits(); refreshLabelList(); renderXP();
    // restore mirror state
    const on = localStorage.getItem(LS_MIRROR)==='1'; const chk=$('#mirrorChk'); if(chk){ chk.checked=on; applyOverlayMirror(on); }
    // initial dict list
    try{ await renderDictList(''); }catch{}
    console.log('[KSL] ready (KRDS ìŠ¤íƒ€ì¼, ì •ë¦¬ë³¸ r8)');
  });
  </script>
</body>
</html>
